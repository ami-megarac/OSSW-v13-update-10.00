From de49fd1b4145c6859eb299986480bb3cbada7edc Mon Sep 17 00:00:00 2001
From: saikumaru <saikumaru@ami.com>
Date: Tue, 12 Aug 2025 17:55:22 +0530
Subject: [PATCH] SDKv907 fix migration for MMC SD

The fixes migratd from following SDK commits,
1.drivers: mmc: Add tuning for HS200/SDR104 support
	https://github.com/AspeedTech-BMC/u-boot/commit/0c85a599e4d17e39e6f78022a63100b17cd013dd
2. sdhci: ast2600: HS200 support porting
	https://github.com/AspeedTech-BMC/u-boot/commit/125f2e11f0b1f726a662ea0abaaf1ba111827377
3. mmc: SD: Add property for timing phase and drive type
	https://github.com/AspeedTech-BMC/u-boot/commit/730fd353d577a66648f8a85c0c2350cf2f92cea0

Signed-off-by: saikumaru <saikumaru@ami.com>
---
 drivers/mmc/aspeed_sdhci.c | 222 ++++++++++++++++++++++++++++++-------
 drivers/mmc/sdhci.c        | 131 ++++++++++++++++++++++
 include/mmc.h              |   1 +
 include/sdhci.h            |  18 +++
 4 files changed, 333 insertions(+), 39 deletions(-)

diff --git a/drivers/mmc/aspeed_sdhci.c b/drivers/mmc/aspeed_sdhci.c
index ee842066..045bfe2c 100644
--- a/drivers/mmc/aspeed_sdhci.c
+++ b/drivers/mmc/aspeed_sdhci.c
@@ -11,36 +11,191 @@
 #include <linux/libfdt.h>
 #include <malloc.h>
 #include <mapmem.h>
+#include <mmc.h>
 #include <sdhci.h>
 #include <clk.h>
 
 /* 400KHz is max freq for card ID etc. Use that as min */
 #define EMMC_MIN_FREQ	400000
 
+#include <power/regulator.h>
+
+#define ASPEED_SDC_PHASE		0xf4
+#define   ASPEED_SDC_S1_PHASE_IN	GENMASK(25, 21)
+#define   ASPEED_SDC_S0_PHASE_IN	GENMASK(20, 16)
+#define   ASPEED_SDC_S0_PHASE_IN_SHIFT	16
+#define   ASPEED_SDC_S0_PHASE_OUT_SHIFT 3
+#define   ASPEED_SDC_S1_PHASE_OUT	GENMASK(15, 11)
+#define   ASPEED_SDC_S1_PHASE_IN_EN	BIT(10)
+#define   ASPEED_SDC_S1_PHASE_OUT_EN	GENMASK(9, 8)
+#define   ASPEED_SDC_S0_PHASE_OUT	GENMASK(7, 3)
+#define   ASPEED_SDC_S0_PHASE_IN_EN	BIT(2)
+#define   ASPEED_SDC_S0_PHASE_OUT_EN	GENMASK(1, 0)
+#define   ASPEED_SDC_PHASE_MAX		31
+
+#define ASPEED_SDHCI_TAP_PARAM_INVERT_CLK	BIT(4)
+#define ASPEED_SDHCI_NR_TAPS		15
+
+#define SDHCI140_SLOT_0_MIRROR_OFFSET 0x10
+#define SDHCI240_SLOT_0_MIRROR_OFFSET 0x20
+#define SDHCI140_SLOT_0_CAP_REG_1_OFFSET 0x140
+#define SDHCI240_SLOT_0_CAP_REG_1_OFFSET 0x240
+
 struct aspeed_sdhci_plat {
 	struct mmc_config cfg;
 	struct mmc mmc;
-	unsigned int f_max;
 };
 
 struct aspeed_sdhci_priv {
 	struct sdhci_host *host;
-	struct clk clk;	
+	struct clk clk;
 };
 
+#ifdef MMC_SUPPORTS_TUNING
+static int aspeed_execute_tuning(struct mmc *mmc, u8 opcode)
+{
+	struct sdhci_host *host = mmc->priv;
+	u32 val, left, right, edge;
+	u32 window, oldwindow = 0, center = 0;
+	u32 in_phase, out_phase, enable_mask, inverted = 0;
+
+	out_phase = sdhci_readl(host, ASPEED_SDC_PHASE) & ASPEED_SDC_S0_PHASE_OUT;
+
+	enable_mask = ASPEED_SDC_S0_PHASE_OUT_EN | ASPEED_SDC_S0_PHASE_IN_EN;
+
+	/*
+	 * There are two window upon clock rising and falling edge.
+	 * Iterate each tap delay to find the valid window and choose the
+	 * bigger one, set the tap delay at the middle of window.
+	 */
+	for (edge = 0; edge < 2; edge++) {
+		if (edge == 1)
+			inverted = ASPEED_SDHCI_TAP_PARAM_INVERT_CLK;
+
+		val = (out_phase | enable_mask | (inverted << ASPEED_SDC_S0_PHASE_IN_SHIFT));
+
+		/* find the left boundary */
+		for (left = 0; left < ASPEED_SDHCI_NR_TAPS + 1; left++) {
+			in_phase = val | (left << ASPEED_SDC_S0_PHASE_IN_SHIFT);
+			sdhci_writel(host, in_phase, ASPEED_SDC_PHASE);
+			if (!mmc_send_tuning(mmc, opcode, NULL))
+				break;
+		}
+
+		/* find the right boundary */
+		for (right = left + 1; right < ASPEED_SDHCI_NR_TAPS + 1; right++) {
+			in_phase = val | (right << ASPEED_SDC_S0_PHASE_IN_SHIFT);
+			sdhci_writel(host, in_phase, ASPEED_SDC_PHASE);
+			if (mmc_send_tuning(mmc, opcode, NULL))
+				break;
+		}
+
+		window = right - left;
+		pr_debug("tuning window[%d][%d~%d] = %d\n", edge, left, right, window);
+
+		if (window > oldwindow) {
+			oldwindow = window;
+			center = (((right - 1) + left) / 2) | inverted;
+		}
+	}
+
+	val = (out_phase | enable_mask | (center << ASPEED_SDC_S0_PHASE_IN_SHIFT));
+	sdhci_writel(host, val, ASPEED_SDC_PHASE);
+
+	pr_debug("input tuning result=%x\n", val);
+
+	inverted = 0;
+	out_phase = val & ~ASPEED_SDC_S0_PHASE_OUT;
+	in_phase = out_phase;
+	oldwindow = 0;
+
+	for (edge = 0; edge < 2; edge++) {
+		if (edge == 1)
+			inverted = ASPEED_SDHCI_TAP_PARAM_INVERT_CLK;
+
+		val = (in_phase | enable_mask | (inverted << ASPEED_SDC_S0_PHASE_OUT_SHIFT));
+
+		/* find the left boundary */
+		for (left = 0; left < ASPEED_SDHCI_NR_TAPS + 1; left++) {
+			out_phase = val | (left << ASPEED_SDC_S0_PHASE_OUT_SHIFT);
+			sdhci_writel(host, out_phase, ASPEED_SDC_PHASE);
+
+			if (!mmc_send_tuning(mmc, opcode, NULL))
+				break;
+		}
+
+		/* find the right boundary */
+		for (right = left + 1; right < ASPEED_SDHCI_NR_TAPS + 1; right++) {
+			out_phase = val | (right << ASPEED_SDC_S0_PHASE_OUT_SHIFT);
+			sdhci_writel(host, out_phase, ASPEED_SDC_PHASE);
+
+			if (mmc_send_tuning(mmc, opcode, NULL))
+				break;
+		}
+
+		window = right - left;
+		pr_debug("tuning window[%d][%d~%d] = %d\n", edge, left, right, window);
+
+		if (window > oldwindow) {
+			oldwindow = window;
+			center = (((right - 1) + left) / 2) | inverted;
+		}
+	}
+
+	val = (in_phase | enable_mask | (center << ASPEED_SDC_S0_PHASE_OUT_SHIFT));
+	sdhci_writel(host, val, ASPEED_SDC_PHASE);
+
+	pr_debug("output tuning result=%x\n", val);
+
+	return mmc_send_tuning(mmc, opcode, NULL);
+}
+
+static void aspeed_set_ios_post(struct sdhci_host *host)
+{
+	struct mmc *mmc = host->mmc;
+	u32 reg;
+	u32 drv;
+
+	drv = dev_read_u32_default(mmc->dev, "sdhci-drive-type", 0);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL_2);
+	reg &= ~SDHCI_DRIVER_STRENGTH_MASK;
+
+	switch (mmc->selected_mode) {
+	case SD_HS:
+	case UHS_SDR50:
+	case UHS_DDR50:
+	case UHS_SDR104:
+		reg |= ((drv & 0x3) << SDHCI_DRIVER_STRENGTH_SHIFT);
+		break;
+	default:
+		break;
+	}
+
+	sdhci_writew(host, reg, SDHCI_HOST_CONTROL_2);
+}
+
+static struct sdhci_ops aspeed_sdhci_ops = {
+	.set_control_reg = sdhci_set_control_reg,
+	.set_ios_post = aspeed_set_ios_post,
+	.platform_execute_tuning = aspeed_execute_tuning,
+};
+#endif
+
 static int aspeed_sdhci_probe(struct udevice *dev)
 {
 	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
 	struct aspeed_sdhci_plat *plat = dev_get_platdata(dev);
 	struct aspeed_sdhci_priv *prv = dev_get_priv(dev);
 	struct sdhci_host *host = prv->host;
+	void *sdhci_reg;
 	unsigned long clock;
-	unsigned long f_max;
+	u32 max_freq;
+	u32 reg_val;
 	struct clk clk;
 	int ret;
-#ifndef CONFIG_SPL_BUILD
-	int node = dev_of_offset(dev);
-#endif
+
+	max_freq = dev_read_u32_default(dev, "max-frequency", 4);
 
 	ret = clk_get_by_index(dev, 0, &clk);
 	if (ret < 0) {
@@ -56,51 +211,40 @@ static int aspeed_sdhci_probe(struct udevice *dev)
 
 	debug("%s: CLK %ld\n", __func__, clock);
 
-#ifndef CONFIG_SPL_BUILD
-	//1: sd card pwr, 0: no pwr
-	gpio_request_by_name_nodev(offset_to_ofnode(node), "pwr-gpios", 0,
-				   &host->pwr_gpio, GPIOD_IS_OUT);
-	if (dm_gpio_is_valid(&host->pwr_gpio)) {
-		printf("\n");
-		dm_gpio_set_value(&host->pwr_gpio, 1);
-		if (ret) {
-			debug("MMC not configured\n");
-			return ret;
-		}
-	}
-
-	//1: 3.3v, 0: 1.8v
-	gpio_request_by_name_nodev(offset_to_ofnode(node), "pwr-sw-gpios", 0,
-				   &host->pwr_sw_gpio, GPIOD_IS_OUT);
+	if (dev_read_bool(dev, "sdhci_hs200")) {
+		sdhci_reg = dev_read_addr_ptr(dev);
+		if (!sdhci_reg)
+			return -EINVAL;
 
-	if (dm_gpio_is_valid(&host->pwr_sw_gpio)) {
-		dm_gpio_set_value(&host->pwr_sw_gpio, 1);
-		if (ret) {
-			debug("MMC not configured\n");
-			return ret;
-		}
+		reg_val = readl(sdhci_reg + SDHCI140_SLOT_0_CAP_REG_1_OFFSET);
+		/* support 1.8V */
+		reg_val |= BIT(26);
+		writel(reg_val, sdhci_reg + SDHCI140_SLOT_0_MIRROR_OFFSET);
+		reg_val = readl(sdhci_reg + SDHCI240_SLOT_0_CAP_REG_1_OFFSET);
+		/* support 1.8V */
+		reg_val |= BIT(26);
+		writel(reg_val, sdhci_reg + SDHCI240_SLOT_0_MIRROR_OFFSET);
 	}
+
+#ifdef MMC_SUPPORTS_TUNING
+	host->ops = &aspeed_sdhci_ops;
 #endif
-//	host->quirks = SDHCI_QUIRK_WAIT_SEND_CMD;
 	host->max_clk = clock;
-	f_max = dev_read_u32_default(dev, "max-frequency", clock);
+	host->mmc = &plat->mmc;
+	host->mmc->dev = dev;
+	host->mmc->priv = host;
+	upriv->mmc = host->mmc;
+	host->mmc->drv_type = dev_read_u32_default(dev, "sdhci-drive-type", 0);
+
 	host->bus_width = dev_read_u32_default(dev, "bus-width", 4);
 
 	if (host->bus_width == 8)
 		host->host_caps |= MMC_MODE_8BIT;
 
-//	ret = sdhci_setup_cfg(&plat->cfg, host, host->max_clk, EMMC_MIN_FREQ);
-	ret = sdhci_setup_cfg(&plat->cfg, host, f_max, EMMC_MIN_FREQ);
-
-	host->mmc = &plat->mmc;
+	ret = sdhci_setup_cfg(&plat->cfg, host, max_freq, 400000);
 	if (ret)
 		return ret;
 
-	host->mmc->drv_type = dev_read_u32_default(dev, "sdhci-drive-type", 0);
-	host->mmc->priv = host;
-	host->mmc->dev = dev;
-	upriv->mmc = host->mmc;
-
 	return sdhci_probe(dev);
 }
 
diff --git a/drivers/mmc/sdhci.c b/drivers/mmc/sdhci.c
index 2505d5b8..31f55a8c 100644
--- a/drivers/mmc/sdhci.c
+++ b/drivers/mmc/sdhci.c
@@ -12,6 +12,7 @@
 #include <malloc.h>
 #include <mmc.h>
 #include <sdhci.h>
+#include <power/regulator.h>
 
 #if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
 void *aligned_buffer = (void *)CONFIG_FIXED_SDHCI_ALIGNED_BUFFER;
@@ -450,6 +451,136 @@ static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
 	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
 }
 
+void sdhci_set_uhs_timing(struct sdhci_host *host)
+{
+	struct mmc *mmc = host->mmc;
+	u32 reg;
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL_2);
+	reg &= ~SDHCI_CTRL_UHS_MASK;
+
+	switch (mmc->selected_mode) {
+	case UHS_SDR25:
+	case MMC_HS:
+		reg |= SDHCI_CTRL_UHS_SDR25;
+		break;
+	case UHS_SDR50:
+	case MMC_HS_52:
+		reg |= SDHCI_CTRL_UHS_SDR50;
+		break;
+	case UHS_DDR50:
+	case MMC_DDR_52:
+		reg |= SDHCI_CTRL_UHS_DDR50;
+		break;
+	case UHS_SDR104:
+	case MMC_HS_200:
+		reg |= SDHCI_CTRL_UHS_SDR104;
+		break;
+	case MMC_HS_400:
+	case MMC_HS_400_ES:
+		reg |= SDHCI_CTRL_HS400;
+		break;
+	default:
+		reg |= SDHCI_CTRL_UHS_SDR12;
+	}
+
+	sdhci_writew(host, reg, SDHCI_HOST_CONTROL_2);
+}
+
+static void sdhci_set_voltage(struct sdhci_host *host)
+{
+	if (IS_ENABLED(CONFIG_MMC_IO_VOLTAGE)) {
+		struct mmc *mmc = (struct mmc *)host->mmc;
+		u32 ctrl;
+
+		ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL_2);
+
+		switch (mmc->signal_voltage) {
+		case MMC_SIGNAL_VOLTAGE_330:
+#if CONFIG_IS_ENABLED(DM_REGULATOR)
+			if (mmc->vqmmc_supply) {
+				if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, false)) {
+					pr_err("failed to disable vqmmc-supply\n");
+					return;
+				}
+
+				if (regulator_set_value(mmc->vqmmc_supply, 3300000)) {
+					pr_err("failed to set vqmmc-voltage to 3.3V\n");
+					return;
+				}
+
+				if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, true)) {
+					pr_err("failed to enable vqmmc-supply\n");
+					return;
+				}
+			}
+#endif
+			if (IS_SD(mmc)) {
+				ctrl &= ~SDHCI_CTRL_VDD_180;
+				sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL_2);
+			}
+
+			/* Wait for 5ms */
+			mdelay(5);
+
+			/* 3.3V regulator output should be stable within 5 ms */
+			if (IS_SD(mmc)) {
+				if (ctrl & SDHCI_CTRL_VDD_180) {
+					pr_err("3.3V regulator output did not become stable\n");
+					return;
+				}
+			}
+
+			break;
+		case MMC_SIGNAL_VOLTAGE_180:
+#if CONFIG_IS_ENABLED(DM_REGULATOR)
+			if (mmc->vqmmc_supply) {
+				if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, false)) {
+					pr_err("failed to disable vqmmc-supply\n");
+					return;
+				}
+
+				if (regulator_set_value(mmc->vqmmc_supply, 1800000)) {
+					pr_err("failed to set vqmmc-voltage to 1.8V\n");
+					return;
+				}
+
+				if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, true)) {
+					pr_err("failed to enable vqmmc-supply\n");
+					return;
+				}
+			}
+#endif
+			if (IS_SD(mmc)) {
+				ctrl |= SDHCI_CTRL_VDD_180;
+				sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL_2);
+			}
+
+			/* Wait for 5 ms */
+			mdelay(5);
+
+			/* 1.8V regulator output has to be stable within 5 ms */
+			if (IS_SD(mmc)) {
+				if (!(ctrl & SDHCI_CTRL_VDD_180)) {
+					pr_err("1.8V regulator output did not become stable\n");
+					return;
+				}
+			}
+
+			break;
+		default:
+			/* No signal voltage switch required */
+			return;
+		}
+	}
+}
+
+void sdhci_set_control_reg(struct sdhci_host *host)
+{
+	sdhci_set_voltage(host);
+	sdhci_set_uhs_timing(host);
+}
+
 #ifdef CONFIG_DM_MMC
 static int sdhci_set_ios(struct udevice *dev)
 {
diff --git a/include/mmc.h b/include/mmc.h
index 4834dbaf..95e3616b 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -526,6 +526,7 @@ enum bus_mode {
 	UHS_SDR104,
 	MMC_HS_200,
 	MMC_HS_400,
+	MMC_HS_400_ES,
 	MMC_MODES_END
 };
 
diff --git a/include/sdhci.h b/include/sdhci.h
index 6f858954..62760b74 100644
--- a/include/sdhci.h
+++ b/include/sdhci.h
@@ -145,6 +145,14 @@
 #define SDHCI_ACMD12_ERR	0x3C
 
 #define SDHCI_HOST_CONTROL_2        0x3E
+#define  SDHCI_CTRL_UHS_MASK	0x0007
+#define  SDHCI_CTRL_UHS_SDR12	0x0000
+#define  SDHCI_CTRL_UHS_SDR25	0x0001
+#define  SDHCI_CTRL_UHS_SDR50	0x0002
+#define  SDHCI_CTRL_UHS_SDR104	0x0003
+#define  SDHCI_CTRL_UHS_DDR50	0x0004
+#define  SDHCI_CTRL_HS400	0x0005 /* Non-standard */
+#define  SDHCI_CTRL_VDD_180	0x0008
 #define SDHCI_DRIVER_STRENGTH_MASK  0x30
 #define SDHCI_DRIVER_STRENGTH_SHIFT 4
 
@@ -431,6 +439,16 @@ int add_sdhci(struct sdhci_host *host, u32 f_max, u32 f_min);
 #ifdef CONFIG_DM_MMC
 /* Export the operations to drivers */
 int sdhci_probe(struct udevice *dev);
+
+/**
+ * sdhci_set_control_reg - Set control registers
+ *
+ * This is used set up control registers for voltage level and UHS speed
+ * mode.
+ *
+ * @host: SDHCI host structure
+ */
+void sdhci_set_control_reg(struct sdhci_host *host);
 extern const struct dm_mmc_ops sdhci_ops;
 #else
 #endif
-- 
2.49.0

