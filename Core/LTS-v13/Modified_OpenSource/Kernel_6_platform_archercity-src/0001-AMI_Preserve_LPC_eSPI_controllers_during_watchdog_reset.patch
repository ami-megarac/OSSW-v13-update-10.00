From 7e5f1bf4605c13f30655a8ae6b7cee8ea965a75e Mon Sep 17 00:00:00 2001
From: saikumaru <saikumaru@ami.com>
Date: Wed, 6 Aug 2025 15:29:43 +0530
Subject: [PATCH] AMI Preserve LPC/eSPI controllers during watchdog restart

During a watchdog-triggered system restart on ASPEED BMC systems, the LPC
(Low Pin Count) and eSPI (Enhanced Serial Peripheral Interface) controllers
were being reset along with other system components. This caused disruption
of communication between the BMC and host system during BMC restarts.

This patch modifies the watchdog restart behavior to selectively preserve
the LPC and eSPI controllers by:

1. Clearing the reset bits (0x4000800) for LPC and eSPI controllers in both
   the Watchdog Reset Mask 2 register and SCU register 0x70 before
   triggering the restart
2. Temporarily unlocking the SCU (System Control Unit) registers to allow
   the modification
3. Adding proper memory mapping for SCU registers during driver probe

This ensures that critical host-BMC communication interfaces remain
functional during BMC restarts, which is essential for server management
and monitoring operations in enterprise environments.

The change specifically targets ASPEED BMC chips commonly used in server
motherboards where maintaining host connectivity during BMC restarts is
crucial for system reliability.

Signed-off-by: saikumaru <saikumaru@ami.com>
---
 drivers/watchdog/aspeed_wdt.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/drivers/watchdog/aspeed_wdt.c b/drivers/watchdog/aspeed_wdt.c
index 7c9400b5d..65914b5cb 100644
--- a/drivers/watchdog/aspeed_wdt.c
+++ b/drivers/watchdog/aspeed_wdt.c
@@ -228,11 +228,16 @@ static void wdt_writel_delay(u32 val, void __iomem *addr)
 #define MAX_WDT_DEVICES 1
 #define WDT_PRETIMEOUT_SIGNAL 46
 
+#define AST_SCU_REG_BASE   0x1E6E2000
+#define AST_SCU_REG_LEN    SZ_4K
+
+
 extern int *current_wdt_no ;
 static int old_wdt_no = 1;
 int *old_wdt =& old_wdt_no ;
 static int current_wdt_device = 1;
 static void *ast_watchdog_virt_base;
+static void *ast_scu_virt_base;
 static u32 current_receiver_pid=0;
 static u32 current_extend_time=0;
 static int wdt_irq=0;
@@ -323,6 +328,16 @@ static int aspeed_wdt_restart(struct watchdog_device *wdd,
 	wdt->ctrl &= ~WDT_CTRL_BOOT_SECONDARY;
 	aspeed_wdt_enable(wdt, 128 * WDT_RATE_1MHZ / 1000);
 
+	//Disable reset LPC and eSPI controller of WDT Reset Mask and SCU Extrst# Reset Selection Registers
+	reg = readl(wdt->base + ((*current_wdt_no - 1)*OFFSET_CALCULATOR) + AST_WATCHDOG_RESET_MASK_2);
+	reg &= ~(0x4000800);
+	wdt->cfg->wdt_writel(reg, wdt->base + ((*current_wdt_no - 1)*OFFSET_CALCULATOR) + AST_WATCHDOG_RESET_MASK_2);
+	wdt->cfg->wdt_writel(0x1688A8A8, (void __iomem*)ast_scu_virt_base + 0x0);
+	reg = readl((void __iomem*)ast_scu_virt_base + 0x70);
+	reg &= ~(0x4000800);
+	wdt->cfg->wdt_writel(reg, (void __iomem*)ast_scu_virt_base + 0x70);
+	wdt->cfg->wdt_writel(0x0, (void __iomem*)ast_scu_virt_base + 0x0);
+
 	mdelay(1000);
 
 	return 0;
@@ -749,6 +764,15 @@ static int aspeed_wdt_probe(struct platform_device *pdev)
 	}
 
 	dev_set_drvdata(dev, wdt);
+
+       ast_scu_virt_base = ioremap(AST_SCU_REG_BASE, AST_SCU_REG_LEN);
+       if (!ast_scu_virt_base) 
+       {
+		printk("ioremap WDT failed\n");
+		return -ENOMEM;
+       }
+
+
        ast_watchdog_virt_base = ioremap(AST_WATCHDOG_REG_BASE, AST_WATCHDOG_REG_LEN);
 
        if(irq != 0)
-- 
2.49.0

