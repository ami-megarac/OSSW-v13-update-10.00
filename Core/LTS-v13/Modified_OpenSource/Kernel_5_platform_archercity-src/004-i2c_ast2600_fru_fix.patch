--- linux/drivers/i2c/busses/i2c-ast2600.c	2024-07-31 20:23:32.000000000 +0800
+++ linux_mdf/drivers/i2c/busses/i2c-ast2600.c	2024-07-31 23:40:54.000000000 +0800
@@ -262,9 +262,12 @@
         int ret = 0;
         u32 ctrl;
         int r;
+        unsigned long flags;
         TmpI2CLinkStatus = I2C_UNDER_RCV;
         dev_dbg(i2c_bus->dev, "%d-bus recovery bus [%x]\n", i2c_bus->adap.nr, state);
 
+        mdelay(20);
+        spin_lock_irqsave(&i2c_bus->lock, flags);
         ctrl = readl(i2c_bus->reg_base + AST2600_I2CC_FUN_CTRL);
 
         /* Disable master/slave mode */
@@ -282,6 +285,7 @@
         state = readl(i2c_bus->reg_base + AST2600_I2CC_STS_AND_BUFF);
         if (!(state & AST2600_I2CC_SDA_LINE_STS) && (state & AST2600_I2CC_SCL_LINE_STS)) {
                 writel(AST2600_I2CM_RECOVER_CMD_EN, i2c_bus->reg_base + AST2600_I2CM_CMD_STS);
+                spin_unlock_irqrestore(&i2c_bus->lock, flags);
                 r = wait_for_completion_timeout(&i2c_bus->cmd_complete, i2c_bus->adap.timeout);
                 if (r == 0) {
                         dev_dbg(i2c_bus->dev, "recovery timed out\n");
@@ -293,6 +297,8 @@
                         }
                 }
         }
+        else
+                spin_unlock_irqrestore(&i2c_bus->lock, flags);
 
         /* Recovery done */
         state = readl(i2c_bus->reg_base + AST2600_I2CC_STS_AND_BUFF);
@@ -1926,15 +1932,20 @@
 {
         struct ast2600_i2c_bus *i2c_bus = dev_id;
 
+        spin_lock(&i2c_bus->lock);
 #ifdef CONFIG_I2C_SLAVE
         if (readl(i2c_bus->reg_base + AST2600_I2CC_FUN_CTRL) & AST2600_I2CC_SLAVE_EN) {
                 if (ast2600_i2c_slave_irq(i2c_bus)) {
 //                      dev_dbg(i2c_bus->dev, "bus-%d.slave handle\n", i2c_bus->adap.nr);
+                        spin_unlock(&i2c_bus->lock);
                         return IRQ_HANDLED;
                 }
         }
 #endif
-        return ast2600_i2c_master_irq(i2c_bus) ? IRQ_HANDLED : IRQ_NONE;
+
+        irq=ast2600_i2c_master_irq(i2c_bus);
+        spin_unlock(&i2c_bus->lock);
+        return irq ? IRQ_HANDLED : IRQ_NONE;
 }
 
 static void ast2600_smbus_try_get_dmabuf(struct i2c_msg *msg, u8 init_val)
@@ -2238,7 +2249,7 @@
 static int ast2600_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 {
         struct ast2600_i2c_bus *i2c_bus = i2c_get_adapdata(adap);
-        unsigned long timeout;
+        unsigned long timeout, flags;
         int ret;
 
         /* If bus is busy in a single master environment, attempt recovery. */
@@ -2263,6 +2274,7 @@
         }
 #endif
 
+        spin_lock_irqsave(&i2c_bus->lock, flags);
         i2c_bus->cmd_err = 0;
         i2c_bus->msgs = msgs;
         i2c_bus->msgs_index = 0;
@@ -2275,9 +2287,11 @@
         if (i2c_bus->mode == BUFF_MODE)
                 writel(AST2600_I2CS_PKT_DONE, i2c_bus->reg_base + AST2600_I2CS_IER);
 #endif
+        spin_unlock_irqrestore(&i2c_bus->lock, flags);
         if (ret)
                 goto master_out;
         timeout = wait_for_completion_timeout(&i2c_bus->cmd_complete, i2c_bus->adap.timeout);
+        spin_lock_irqsave(&i2c_bus->lock, flags);
         if (timeout == 0) {
                 u32 ctrl = readl(i2c_bus->reg_base + AST2600_I2CC_FUN_CTRL);
                 i2c_bus->cmd_err = -ENXIO;
@@ -2316,7 +2330,7 @@
 	} else {
 		ret = i2c_bus->cmd_err;
 	}
-
+        spin_unlock_irqrestore(&i2c_bus->lock, flags);
         dev_dbg(i2c_bus->dev, "bus%d-m: %d end\n", i2c_bus->adap.nr, i2c_bus->cmd_err);
 
 master_out:
@@ -2384,9 +2398,13 @@
 {
         struct ast2600_i2c_bus *i2c_bus = i2c_get_adapdata(client->adapter);
         u32 cmd = SLAVE_TRIGGER_CMD;
+        unsigned long flags;
 
-        if (i2c_bus->slave)
+        spin_lock_irqsave(&i2c_bus->lock, flags);
+        if (i2c_bus->slave){
+                spin_unlock_irqrestore(&i2c_bus->lock, flags);
                 return -EINVAL;
+        }
 
         dev_dbg(i2c_bus->dev, "slave addr %x\n", client->addr);
 
@@ -2413,13 +2431,20 @@
         writel(client->addr | AST2600_I2CS_ADDR1_ENABLE,
                         i2c_bus->reg_base + AST2600_I2CS_ADDR_CTRL);
 
+        spin_unlock_irqrestore(&i2c_bus->lock, flags);
         return 0;
 }
 
 static int ast2600_i2c_unreg_slave(struct i2c_client *slave)
 {
         struct ast2600_i2c_bus *i2c_bus = i2c_get_adapdata(slave->adapter);
+        unsigned long flags;
 
+        spin_lock_irqsave(&i2c_bus->lock, flags);
+        if (!i2c_bus->slave) {
+                spin_unlock_irqrestore(&i2c_bus->lock, flags);
+                return -EINVAL;
+        }
         /* Turn off slave mode. */
         writel(~AST2600_I2CC_SLAVE_EN & readl(i2c_bus->reg_base + AST2600_I2CC_FUN_CTRL),
                i2c_bus->reg_base + AST2600_I2CC_FUN_CTRL);
@@ -2427,6 +2452,7 @@
                i2c_bus->reg_base + AST2600_I2CS_ADDR_CTRL);
 
         i2c_bus->slave = NULL;
+        spin_unlock_irqrestore(&i2c_bus->lock, flags);
 
         return 0;
 }
@@ -2590,6 +2616,8 @@
                 retry = 0;
         }
         /* Initialize the I2C adapter */
+        spin_lock_init(&i2c_bus->lock);
+        init_completion(&i2c_bus->cmd_complete);
         i2c_bus->adap.owner = THIS_MODULE;
         i2c_bus->adap.algo = &i2c_ast2600_algorithm;
         i2c_bus->adap.retries = retry;
--- linux_org/include/linux/i2c.h	2024-07-30 23:44:25.000000000 +0800
+++ linux_ac/include/linux/i2c.h	2024-07-31 23:32:44.276495071 +0800
@@ -1106,6 +1106,7 @@
 	/* 0: old mode, 1: new mode */
 	int					clk_div_mode;
 	struct clk			*clk;
+        spinlock_t                      lock;
 	u32					apb_clk;
 	u32					bus_frequency;
 	int					slave_operate;
