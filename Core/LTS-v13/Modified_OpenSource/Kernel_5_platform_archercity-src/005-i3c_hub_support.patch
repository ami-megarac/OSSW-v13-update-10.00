diff -Naur linux_org/drivers/i3c/device.c linux/drivers/i3c/device.c
--- linux_org/drivers/i3c/device.c	2024-02-06 01:18:16.239869641 +0800
+++ linux/drivers/i3c/device.c	2024-02-15 01:31:23.000000000 +0800
@@ -93,7 +93,6 @@
 	return ret;
 }
 EXPORT_SYMBOL_GPL(i3c_device_send_hdr_cmds);
-
 /**
  * i3c_device_generate_ibi() - request In-Band Interrupt
  *
@@ -118,6 +117,40 @@
 EXPORT_SYMBOL_GPL(i3c_device_generate_ibi);
 
 /**
+ * i3c_device_put_read_data() - put read data and optionally notify primary master
+ *
+ * @dev: target device
+ * @xfers: array of transfers
+ * @nxfers: number of transfers
+ * @ibi_data: IBI payload
+ * @ibi_len: IBI payload length in bytes
+ *
+ * Put read data into the target buffer and optionally notify primary master
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int i3c_device_put_read_data(struct i3c_device *dev, struct i3c_priv_xfer *xfers, int nxfers,
+			     const u8 *ibi_data, int ibi_len)
+{
+	int ret, i;
+
+	if (nxfers < 1)
+		return 0;
+
+	for (i = 0; i < nxfers; i++) {
+		if (!xfers[i].len || !xfers[i].data.in)
+			return -EINVAL;
+	}
+
+	i3c_bus_normaluse_lock(dev->bus);
+	ret = i3c_dev_put_read_data_locked(dev->desc, xfers, nxfers, ibi_data, ibi_len);
+	i3c_bus_normaluse_unlock(dev->bus);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i3c_device_put_read_data);
+
+/**
  * i3c_device_get_info() - get I3C device information
  *
  * @dev: device we want information on
@@ -422,6 +455,20 @@
 EXPORT_SYMBOL_GPL(i3c_device_control_pec);
 
 /**
+ * i3c_device_register_event_cb() - register callback for I3C framework event.
+ * @dev: the I3C device driver handle.
+ * @ev: I3C framework event callback
+ *
+ * This function allows I3C device driver to register for I3C framework events.
+ * Provided callback will be used by controller driver to publish events.
+ */
+void i3c_device_register_event_cb(struct i3c_device *dev, i3c_event_cb event_cb)
+{
+	dev->desc->event_cb = event_cb;
+}
+EXPORT_SYMBOL_GPL(i3c_device_register_event_cb);
+
+/**
  * i3c_device_setmrl_ccc() - set maximum read length
  *
  * @dev: I3C device to set the length for
diff -Naur linux_org/drivers/i3c/i3cdev.c linux/drivers/i3c/i3cdev.c
--- linux_org/drivers/i3c/i3cdev.c	2024-02-06 01:18:16.243869582 +0800
+++ linux/drivers/i3c/i3cdev.c	2024-02-15 00:00:02.542932831 +0800
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) 2020 Synopsys, Inc. and/or its affiliates.
+ * Copyright (c) 2019 Synopsys, Inc. and/or its affiliates.
  *
  * Author: Vitor Soares <soares@synopsys.com>
  */
@@ -12,6 +12,7 @@
 #include <linux/init.h>
 #include <linux/jiffies.h>
 #include <linux/kernel.h>
+#include <linux/list.h>
 #include <linux/module.h>
 #include <linux/notifier.h>
 #include <linux/slab.h>
@@ -22,16 +23,36 @@
 #include "internals.h"
 
 struct i3cdev_data {
+	struct list_head list;
 	struct i3c_device *i3c;
-	struct device *dev;
-	struct mutex xfer_lock; /* prevent detach while transferring */
 	struct cdev cdev;
+	struct device *dev;
 	int id;
 };
 
 static DEFINE_IDA(i3cdev_ida);
 static dev_t i3cdev_number;
-#define I3C_MINORS (MINORMASK + 1)
+#define I3C_MINORS 64 /* 64 I3C devices supported for now */
+
+static LIST_HEAD(i3cdev_list);
+static DEFINE_SPINLOCK(i3cdev_list_lock);
+
+static struct i3cdev_data *i3cdev_get_by_i3c(struct i3c_device *i3c)
+{
+	struct i3cdev_data *i3cdev;
+
+	spin_lock(&i3cdev_list_lock);
+	list_for_each_entry(i3cdev, &i3cdev_list, list) {
+		if (i3cdev->i3c == i3c)
+			goto found;
+	}
+
+	i3cdev = NULL;
+
+found:
+	spin_unlock(&i3cdev_list_lock);
+	return i3cdev;
+}
 
 static struct i3cdev_data *get_free_i3cdev(struct i3c_device *i3c)
 {
@@ -52,32 +73,32 @@
 
 	i3cdev->i3c = i3c;
 	i3cdev->id = id;
-	i3cdev_set_drvdata(i3c, i3cdev);
+
+	spin_lock(&i3cdev_list_lock);
+	list_add_tail(&i3cdev->list, &i3cdev_list);
+	spin_unlock(&i3cdev_list_lock);
 
 	return i3cdev;
 }
 
 static void put_i3cdev(struct i3cdev_data *i3cdev)
 {
-	i3cdev_set_drvdata(i3cdev->i3c, NULL);
+	spin_lock(&i3cdev_list_lock);
+	list_del(&i3cdev->list);
+	spin_unlock(&i3cdev_list_lock);
 	kfree(i3cdev);
 }
 
 static ssize_t
 i3cdev_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
 {
-	struct i3cdev_data *i3cdev = file->private_data;
-	struct i3c_device *i3c = i3cdev->i3c;
+	struct i3c_device *i3c = file->private_data;
 	struct i3c_priv_xfer xfers = {
 		.rnw = true,
 		.len = count,
 	};
-	int ret = -EACCES;
 	char *tmp;
-
-	mutex_lock(&i3cdev->xfer_lock);
-	if (!IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE) && i3c->dev.driver)
-		goto err_out;
+	int ret;
 
 	tmp = kzalloc(count, GFP_KERNEL);
 	if (!tmp)
@@ -89,12 +110,9 @@
 
 	ret = i3c_device_do_priv_xfers(i3c, &xfers, 1);
 	if (!ret)
-		ret = copy_to_user(buf, tmp, xfers.len) ? -EFAULT : xfers.len;
+		ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;
 
 	kfree(tmp);
-
-err_out:
-	mutex_unlock(&i3cdev->xfer_lock);
 	return ret;
 }
 
@@ -102,18 +120,13 @@
 i3cdev_write(struct file *file, const char __user *buf, size_t count,
 	     loff_t *f_pos)
 {
-	struct i3cdev_data *i3cdev = file->private_data;
-	struct i3c_device *i3c = i3cdev->i3c;
+	struct i3c_device *i3c = file->private_data;
 	struct i3c_priv_xfer xfers = {
 		.rnw = false,
 		.len = count,
 	};
-	int ret = -EACCES;
 	char *tmp;
-
-	mutex_lock(&i3cdev->xfer_lock);
-	if (!IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE) && i3c->dev.driver)
-		goto err_out;
+	int ret;
 
 	tmp = memdup_user(buf, count);
 	if (IS_ERR(tmp))
@@ -125,9 +138,6 @@
 
 	ret = i3c_device_do_priv_xfers(i3c, &xfers, 1);
 	kfree(tmp);
-
-err_out:
-	mutex_unlock(&i3cdev->xfer_lock);
 	return (!ret) ? count : ret;
 }
 
@@ -139,14 +149,15 @@
 	u8 **data_ptrs;
 	int i, ret = 0;
 
-	/* Since we have nxfers we may allocate k_xfer + *data_ptrs together */
-	k_xfers = kcalloc(nxfers, sizeof(*k_xfers) + sizeof(*data_ptrs),
-			  GFP_KERNEL);
+	k_xfers = kcalloc(nxfers, sizeof(*k_xfers), GFP_KERNEL);
 	if (!k_xfers)
 		return -ENOMEM;
 
-	/* set data_ptrs to be after nxfers * i3c_priv_xfer */
-	data_ptrs = (void *)k_xfers + (nxfers * sizeof(*k_xfers));
+	data_ptrs = kcalloc(nxfers, sizeof(*data_ptrs), GFP_KERNEL);
+	if (!data_ptrs) {
+		ret = -ENOMEM;
+		goto err_free_k_xfer;
+	}
 
 	for (i = 0; i < nxfers; i++) {
 		data_ptrs[i] = memdup_user((const u8 __user *)
@@ -178,75 +189,7 @@
 
 	for (i = 0; i < nxfers; i++) {
 		if (xfers[i].rnw) {
-			if (copy_to_user(u64_to_user_ptr(xfers[i].data),
-					 data_ptrs[i], xfers[i].len))
-				ret = -EFAULT;
-		}
-	}
-
-err_free_mem:
-	for (; i >= 0; i--)
-		kfree(data_ptrs[i]);
-	kfree(k_xfers);
-	return ret;
-}
-
-static int
-i3cdev_send_hdr_xfer(struct i3c_device *dev, struct i3c_ioc_priv_xfer *xfers,
-		    unsigned int nxfers)
-{
-	struct i3c_hdr_cmd *k_xfers;
-	u8 **data_ptrs;
-	u16 xfer_len;
-	int i, ret = 0;
-
-	/* Since we have nxfers we may allocate k_xfer + *data_ptrs together */
-	k_xfers = kcalloc(nxfers, sizeof(*k_xfers) + sizeof(*data_ptrs),
-			  GFP_KERNEL);
-	if (!k_xfers)
-		return -ENOMEM;
-
-	/* set data_ptrs to be after nxfers * i3c_priv_xfer */
-	data_ptrs = (void *)k_xfers + (nxfers * sizeof(*k_xfers));
-
-	for (i = 0; i < nxfers; i++) {
-		xfer_len = roundup(xfers[i].len, 2);
-		data_ptrs[i] = kzalloc(xfer_len, GFP_KERNEL);
-		if (!data_ptrs[i])
-			return -ENOMEM;
-		if (copy_from_user(data_ptrs[i],
-				   (const u8 __user *)(uintptr_t)xfers[i].data,
-				   xfers[i].len)) {
-			kfree(data_ptrs[i]);
-			return -EFAULT;
-		}
-		if (IS_ERR(data_ptrs[i])) {
-			ret = PTR_ERR(data_ptrs[i]);
-			break;
-		}
-		k_xfers[i].mode = I3C_HDR_DDR;
-		k_xfers[i].ndatawords = DIV_ROUND_UP(xfers[i].len, 2);
-		if (xfers[i].rnw) {
-			k_xfers[i].code = 0x80;
-			k_xfers[i].data.in = data_ptrs[i];
-		} else {
-			k_xfers[i].code = 0;
-			k_xfers[i].data.out = data_ptrs[i];
-		}
-	}
-
-	if (ret < 0) {
-		i--;
-		goto err_free_mem;
-	}
-
-	ret = i3c_device_send_hdr_cmds(dev, k_xfers, nxfers);
-	if (ret)
-		goto err_free_mem;
-
-	for (i = 0; i < nxfers; i++) {
-		if (xfers[i].rnw) {
-			if (copy_to_user(u64_to_user_ptr(xfers[i].data),
+			if (copy_to_user((void __user *)(uintptr_t)xfers[i].data,
 					 data_ptrs[i], xfers[i].len))
 				ret = -EFAULT;
 		}
@@ -255,6 +198,8 @@
 err_free_mem:
 	for (; i >= 0; i--)
 		kfree(data_ptrs[i]);
+	kfree(data_ptrs);
+err_free_k_xfer:
 	kfree(k_xfers);
 	return ret;
 }
@@ -270,7 +215,7 @@
 
 	*nxfers = tmp / sizeof(struct i3c_ioc_priv_xfer);
 	if (*nxfers == 0)
-		return ERR_PTR(-EINVAL);
+		return NULL;
 
 	return memdup_user(u_xfers, tmp);
 }
@@ -284,14 +229,10 @@
 	int ret;
 
 	k_xfers = i3cdev_get_ioc_priv_xfer(cmd, u_xfers, &nxfers);
-	if (IS_ERR(k_xfers))
+	if (IS_ERR_OR_NULL(k_xfers))
 		return PTR_ERR(k_xfers);
 
-	if (i3c->desc->info.hdr_cap & BIT(I3C_HDR_DDR) &&
-	    IS_ENABLED(CONFIG_I3CDEV_XFER_HDR_DDR))
-		ret = i3cdev_send_hdr_xfer(i3c, k_xfers, nxfers);
-	else
-		ret = i3cdev_do_priv_xfer(i3c, k_xfers, nxfers);
+	ret = i3cdev_do_priv_xfer(i3c, k_xfers, nxfers);
 
 	kfree(k_xfers);
 
@@ -301,29 +242,20 @@
 static long
 i3cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct i3cdev_data *i3cdev = file->private_data;
-	struct i3c_device *i3c = i3cdev->i3c;
-	int ret = -EACCES;
+	struct i3c_device *i3c = file->private_data;
 
 	dev_dbg(&i3c->dev, "ioctl, cmd=0x%02x, arg=0x%02lx\n", cmd, arg);
 
 	if (_IOC_TYPE(cmd) != I3C_DEV_IOC_MAGIC)
 		return -ENOTTY;
 
-	/* Use the xfer_lock to prevent device detach during ioctl call */
-	mutex_lock(&i3cdev->xfer_lock);
-	if (!IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE) && i3c->dev.driver)
-		goto err_no_dev;
-
 	/* Check command number and direction */
 	if (_IOC_NR(cmd) == _IOC_NR(I3C_IOC_PRIV_XFER(0)) &&
 	    _IOC_DIR(cmd) == (_IOC_READ | _IOC_WRITE))
-		ret = i3cdev_ioc_priv_xfer(i3c, cmd,
+		return i3cdev_ioc_priv_xfer(i3c, cmd,
 					(struct i3c_ioc_priv_xfer __user *)arg);
 
-err_no_dev:
-	mutex_unlock(&i3cdev->xfer_lock);
-	return ret;
+	return 0;
 }
 
 static int i3cdev_open(struct inode *inode, struct file *file)
@@ -331,7 +263,8 @@
 	struct i3cdev_data *i3cdev = container_of(inode->i_cdev,
 						  struct i3cdev_data,
 						  cdev);
-	file->private_data = i3cdev;
+
+	file->private_data = i3cdev->i3c;
 
 	return 0;
 }
@@ -348,7 +281,6 @@
 	.read		= i3cdev_read,
 	.write		= i3cdev_write,
 	.unlocked_ioctl	= i3cdev_ioctl,
-	.compat_ioctl	= compat_ptr_ioctl,
 	.open		= i3cdev_open,
 	.release	= i3cdev_release,
 };
@@ -363,10 +295,7 @@
 	struct i3c_device *i3c;
 	int res;
 
-	if (dev->type == &i3c_masterdev_type)
-		return 0;
-
-	if (!IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE) && dev->driver)
+	if (dev->type == &i3c_masterdev_type || dev->driver)
 		return 0;
 
 	i3c = dev_to_i3cdev(dev);
@@ -376,7 +305,6 @@
 	if (IS_ERR(i3cdev))
 		return PTR_ERR(i3cdev);
 
-	mutex_init(&i3cdev->xfer_lock);
 	cdev_init(&i3cdev->cdev, &i3cdev_fops);
 	i3cdev->cdev.owner = THIS_MODULE;
 	res = cdev_add(&i3cdev->cdev,
@@ -413,16 +341,12 @@
 
 	i3c = dev_to_i3cdev(dev);
 
-	i3cdev = i3cdev_get_drvdata(i3c);
+	i3cdev = i3cdev_get_by_i3c(i3c);
 	if (!i3cdev)
 		return 0;
 
-	/* Prevent transfers while cdev removal */
-	mutex_lock(&i3cdev->xfer_lock);
 	cdev_del(&i3cdev->cdev);
 	device_destroy(i3cdev_class, MKDEV(MAJOR(i3cdev_number), i3cdev->id));
-	mutex_unlock(&i3cdev->xfer_lock);
-
 	ida_simple_remove(&i3cdev_ida, i3cdev->id);
 	put_i3cdev(i3cdev);
 
@@ -441,12 +365,8 @@
 	case BUS_NOTIFY_ADD_DEVICE:
 	case BUS_NOTIFY_UNBOUND_DRIVER:
 		return i3cdev_attach(dev, NULL);
-	case BUS_NOTIFY_BIND_DRIVER:
-		if (IS_ENABLED(CONFIG_I3CDEV_FORCE_CREATE))
-			break;
-
-		fallthrough;
 	case BUS_NOTIFY_DEL_DEVICE:
+	case BUS_NOTIFY_BOUND_DRIVER:
 	case BUS_NOTIFY_REMOVED_DEVICE:
 		return i3cdev_detach(dev, NULL);
 	}
@@ -454,7 +374,7 @@
 	return 0;
 }
 
-static struct notifier_block i3cdev_notifier = {
+static struct notifier_block i3c_notifier = {
 	.notifier_call = i3cdev_notifier_call,
 };
 
@@ -475,7 +395,7 @@
 	}
 
 	/* Keep track of busses which have devices to add or remove later */
-	res = bus_register_notifier(&i3c_bus_type, &i3cdev_notifier);
+	res = bus_register_notifier(&i3c_bus_type, &i3c_notifier);
 	if (res)
 		goto out_unreg_class;
 
@@ -495,7 +415,7 @@
 
 static void __exit i3cdev_exit(void)
 {
-	bus_unregister_notifier(&i3c_bus_type, &i3cdev_notifier);
+	bus_unregister_notifier(&i3c_bus_type, &i3c_notifier);
 	i3c_for_each_dev(NULL, i3cdev_detach);
 	class_destroy(i3cdev_class);
 	unregister_chrdev_region(i3cdev_number, I3C_MINORS);
diff -Naur linux_org/drivers/i3c/i3c-hub.c linux/drivers/i3c/i3c-hub.c
--- linux_org/drivers/i3c/i3c-hub.c	2024-02-06 01:18:16.243869582 +0800
+++ linux/drivers/i3c/i3c-hub.c	2024-02-15 01:28:26.293359500 +0800
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright (C) 2021 Intel Corporation.*/
 
+#include <linux/ktime.h>
 #include <linux/bitfield.h>
 #include <linux/debugfs.h>
 #include <linux/module.h>
@@ -12,6 +13,8 @@
 
 #define I3C_HUB_TP_MAX_COUNT				0x08
 
+#define I3C_HUB_LOGICAL_BUS_MAX_COUNT			0x08
+
 /* I3C HUB REGISTERS */
 
 /*
@@ -45,6 +48,19 @@
 
 #define I3C_HUB_DEV_CONF				0x13
 #define I3C_HUB_IO_STRENGTH				0x14
+#define  TP0145_IO_STRENGTH_MASK			GENMASK(1, 0)
+#define  TP0145_IO_STRENGTH(x)				(((x) << 0) & TP0145_IO_STRENGTH_MASK)
+#define  TP2367_IO_STRENGTH_MASK			GENMASK(3, 2)
+#define  TP2367_IO_STRENGTH(x)				(((x) << 2) & TP2367_IO_STRENGTH_MASK)
+#define  CP0_IO_STRENGTH_MASK				GENMASK(5, 4)
+#define  CP0_IO_STRENGTH(x)				(((x) << 4) & CP0_IO_STRENGTH_MASK)
+#define  CP1_IO_STRENGTH_MASK				GENMASK(7, 6)
+#define  CP1_IO_STRENGTH(x)				(((x) << 6) & CP1_IO_STRENGTH_MASK)
+#define  IO_STRENGTH_20_OHM				0x00
+#define  IO_STRENGTH_30_OHM				0x01
+#define  IO_STRENGTH_40_OHM				0x02
+#define  IO_STRENGTH_50_OHM				0x03
+
 #define I3C_HUB_NET_OPER_MODE_CONF			0x15
 #define I3C_HUB_LDO_CONF				0x16
 #define  CP0_LDO_VOLTAGE_MASK				GENMASK(1, 0)
@@ -95,7 +111,9 @@
 
 /* Controller Port Control/Status Registers */
 #define I3C_HUB_CP_MUX_SET				0x38
+#define  CONTROLLER_PORT_MUX_REQ			BIT(0)
 #define I3C_HUB_CP_MUX_STS				0x39
+#define  CONTROLLER_PORT_MUX_CONNECTION_STATUS		BIT(0)
 
 /* Target Ports Control Registers */
 #define I3C_HUB_TP_SMBUS_AGNT_TRANS_START		0x50
@@ -130,8 +148,27 @@
 #define I3C_HUB_TP7_SMBUS_AGNT_STS			0x6B
 #define I3C_HUB_ONCHIP_TD_AND_SMBUS_AGNT_CONF		0x6C
 
+/* Transaction status checking mask */
+#define I3C_HUB_XFER_SUCCESS				0x01
+#define I3C_HUB_TP_BUFFER_STATUS_MASK			0x0F
+#define I3C_HUB_TP_TRANSACTION_CODE_MASK		0xF0
+#define I3C_HUB_TARGET_BUF_0_RECEIVE			BIT(1)
+#define I3C_HUB_TARGET_BUF_1_RECEIVE			BIT(2)
+#define I3C_HUB_TARGET_BUF_OVRFL			BIT(3)
+
 /* Special Function Registers */
 #define I3C_HUB_LDO_AND_CPSEL_STS			0x79
+#define  CP_SDA1_LEVEL					BIT(7)
+#define  CP_SCL1_LEVEL					BIT(6)
+#define  CP_SEL_PIN_INPUT_CODE_MASK			GENMASK(5, 4)
+#define  CP_SEL_PIN_INPUT_CODE_GET(x)			(((x) & CP_SEL_PIN_INPUT_CODE_MASK) >> 4)
+#define  CP_SDA1_SCL1_PINS_CODE_MASK			GENMASK(7, 6)
+#define  CP_SDA1_SCL1_PINS_CODE_GET(x)			(((x) & CP_SDA1_SCL1_PINS_CODE_MASK) >> 6)
+#define  VCCIO1_PWR_GOOD				BIT(3)
+#define  VCCIO0_PWR_GOOD				BIT(2)
+#define  CP1_VCCIO_PWR_GOOD				BIT(1)
+#define  CP0_VCCIO_PWR_GOOD				BIT(0)
+
 #define I3C_HUB_BUS_RESET_SCL_TIMEOUT			0x7A
 #define I3C_HUB_ONCHIP_TD_PROTO_ERR_FLG			0x7B
 #define I3C_HUB_DEV_CMD					0x7C
@@ -147,6 +184,14 @@
 #define I3C_HUB_DT_LDO_1_8V				0x04
 #define I3C_HUB_DT_LDO_NOT_DEFINED			0xFF
 
+/* Paged Transaction Registers */
+#define I3C_HUB_CONTROLLER_BUFFER_PAGE			0x10
+#define I3C_HUB_CONTROLLER_AGENT_BUFF			0x80
+#define I3C_HUB_CONTROLLER_AGENT_BUFF_DATA		0x84
+#define I3C_HUB_TARGET_BUFF_LENGTH			0x80
+#define I3C_HUB_TARGET_BUFF_ADDRESS			0x81
+#define I3C_HUB_TARGET_BUFF_DATA			0x82
+
 /* Pull-up DT settings */
 #define I3C_HUB_DT_PULLUP_DISABLED			0x00
 #define I3C_HUB_DT_PULLUP_250R				0x01
@@ -168,6 +213,35 @@
 #define I3C_HUB_DT_TP_PULLUP_ENABLED			0x01
 #define I3C_HUB_DT_TP_PULLUP_NOT_DEFINED		0xFF
 
+/* CP/TP IO strength */
+#define I3C_HUB_DT_IO_STRENGTH_20_OHM			0x00
+#define I3C_HUB_DT_IO_STRENGTH_30_OHM			0x01
+#define I3C_HUB_DT_IO_STRENGTH_40_OHM			0x02
+#define I3C_HUB_DT_IO_STRENGTH_50_OHM			0x03
+#define I3C_HUB_DT_IO_STRENGTH_NOT_DEFINED		0xFF
+
+/* SMBus polling */
+#define I3C_HUB_POLLING_ROLL_PERIOD_MS			10
+
+/* SMBus transaction types fields */
+#define I3C_HUB_SMBUS_400kHz				BIT(2)
+
+/* Hub buffer size */
+#define I3C_HUB_CONTROLLER_BUFFER_SIZE			88
+#define I3C_HUB_TARGET_BUFFER_SIZE			80
+#define I3C_HUB_SMBUS_DESCRIPTOR_SIZE			4
+#define I3C_HUB_SMBUS_PAYLOAD_SIZE			(I3C_HUB_CONTROLLER_BUFFER_SIZE - \
+							I3C_HUB_SMBUS_DESCRIPTOR_SIZE)
+#define I3C_HUB_SMBUS_TARGET_PAYLOAD_SIZE		(I3C_HUB_TARGET_BUFFER_SIZE - 2)
+
+/* Hub SMBus timeout time period in nanoseconds */
+#define I3C_HUB_SMBUS_400kHz_TIMEOUT			(10e9 * 8 * \
+							I3C_HUB_CONTROLLER_BUFFER_SIZE / 4e5)
+
+/* ID Extraction */
+#define I3C_HUB_ID_CP_SDA_SCL				0x00
+#define I3C_HUB_ID_CP_SEL				0x01
+
 struct tp_setting {
 	u8 mode;
 	u8 pullup_en;
@@ -180,13 +254,47 @@
 	u8 tp2367_ldo;
 	u8 tp0145_pullup;
 	u8 tp2367_pullup;
+	u8 cp0_io_strength;
+	u8 cp1_io_strength;
+	u8 tp0145_io_strength;
+	u8 tp2367_io_strength;
 	struct tp_setting tp[I3C_HUB_TP_MAX_COUNT];
 };
 
+struct i2c_adapter_group {
+	u8 tp_mask;
+	u8 tp_port;
+	u8 used;
+
+	struct delayed_work delayed_work_polling;
+	struct i2c_client *client;
+	const char *compatible;
+	u8 polling_last_status;
+	int addr;
+};
+
+struct logical_bus {
+	bool available; /* Indicates that logical bus configuration is available in DT. */
+	bool registered; /* Indicates that logical bus was registered in the framework. */
+	u8 tp_map;
+	struct i3c_master_controller controller;
+	struct i2c_adapter_group smbus_port_adapter;
+	struct device_node *of_node;
+	struct i3c_hub *priv;
+};
+
 struct i3c_hub {
 	struct i3c_device *i3cdev;
+	struct i3c_master_controller *controller;
 	struct regmap *regmap;
 	struct dt_settings settings;
+	struct delayed_work delayed_work;
+	int hub_pin_sel_id;
+	int hub_pin_cp1_id;
+	int hub_dt_sel_id;
+	int hub_dt_cp1_id;
+
+	struct logical_bus logical_bus[I3C_HUB_LOGICAL_BUS_MAX_COUNT];
 
 	/* Offset for reading HUB's register. */
 	u8 reg_addr;
@@ -227,6 +335,13 @@
 	{"enabled",	I3C_HUB_DT_TP_PULLUP_ENABLED},
 };
 
+static const struct hub_setting io_strength_settings[] = {
+	{"20Ohms",	I3C_HUB_DT_IO_STRENGTH_20_OHM},
+	{"30Ohms",	I3C_HUB_DT_IO_STRENGTH_30_OHM},
+	{"40Ohms",	I3C_HUB_DT_IO_STRENGTH_40_OHM},
+	{"50Ohms",	I3C_HUB_DT_IO_STRENGTH_50_OHM},
+};
+
 static u8 i3c_hub_ldo_dt_to_reg(u8 dt_value)
 {
 	switch (dt_value) {
@@ -255,103 +370,101 @@
 	}
 }
 
-static int i3c_hub_of_get_setting(const struct device_node *node, const char *setting_name,
-				  const struct hub_setting settings[], const u8 settings_count,
-				  u8 *setting_value)
+static u8 i3c_hub_io_strength_dt_to_reg(u8 dt_value)
+{
+	switch (dt_value) {
+	case I3C_HUB_DT_IO_STRENGTH_50_OHM:
+		return IO_STRENGTH_50_OHM;
+	case I3C_HUB_DT_IO_STRENGTH_40_OHM:
+		return IO_STRENGTH_40_OHM;
+	case I3C_HUB_DT_IO_STRENGTH_30_OHM:
+		return IO_STRENGTH_30_OHM;
+	default:
+		return IO_STRENGTH_20_OHM;
+	}
+}
+
+static void i3c_hub_of_get_setting(struct device *dev, const struct device_node *node,
+				   const char *setting_name, const struct hub_setting settings[],
+				   const u8 settings_count, u8 *setting_value)
 {
 	const char *sval;
 	int ret;
 	int i;
 
 	ret = of_property_read_string(node, setting_name, &sval);
-	if (ret)
-		return ret;
+	if (ret) {
+		if (ret != -EINVAL) /* Lack of property is not considered as a problem. */
+			dev_warn(dev, "No setting or invalid setting for %s, err=%i\n",
+				 setting_name, ret);
+		return;
+	}
 
 	for (i = 0; i < settings_count; ++i) {
 		const struct hub_setting * const setting = &settings[i];
 
 		if (!strcmp(setting->name, sval)) {
 			*setting_value = setting->value;
-			return 0;
+			return;
 		}
 	}
-
-	return -EINVAL;
+	dev_warn(dev, "Unknown setting for %s: '%s'\n", setting_name, sval);
 }
 
 static void i3c_hub_tp_of_get_setting(struct device *dev, const struct device_node *node,
 				      struct tp_setting tp_setting[])
 {
 	struct device_node *tp_node;
-	int id;
+	u32 id;
 
 	for_each_available_child_of_node(node, tp_node) {
-		int ret;
-
 		if (!tp_node->name || of_node_cmp(tp_node->name, "target-port"))
 			continue;
 
 		if (!tp_node->full_name ||
-		    (sscanf(tp_node->full_name, "target-port@%i", &id) != 1)) {
-			dev_warn(dev, "Invalid target port node found in DT - %s\n",
+		    (sscanf(tp_node->full_name, "target-port@%u", &id) != 1)) {
+			dev_warn(dev, "Invalid target port node found in DT: %s\n",
 				 tp_node->full_name);
 			continue;
 		}
 
 		if (id >= I3C_HUB_TP_MAX_COUNT) {
-			dev_warn(dev, "Invalid target port index found in DT - %i\n", id);
+			dev_warn(dev, "Invalid target port index found in DT: %i\n", id);
 			continue;
 		}
-		ret = i3c_hub_of_get_setting(tp_node, "mode", tp_mode_settings,
-					     ARRAY_SIZE(tp_mode_settings), &tp_setting[id].mode);
-		if (ret)
-			dev_warn(dev, "Invalid or not specified setting for target port[%i].mode\n",
-				 id);
-
-		ret = i3c_hub_of_get_setting(tp_node, "pullup", tp_pullup_settings,
-					     ARRAY_SIZE(tp_pullup_settings),
-					     &tp_setting[id].pullup_en);
-		if (ret)
-			dev_warn(dev,
-				 "Invalid or not specified setting for target port[%i].pullup\n",
-				 id);
+		i3c_hub_of_get_setting(dev, tp_node, "mode", tp_mode_settings,
+				       ARRAY_SIZE(tp_mode_settings), &tp_setting[id].mode);
+		i3c_hub_of_get_setting(dev, tp_node, "pullup", tp_pullup_settings,
+				       ARRAY_SIZE(tp_pullup_settings), &tp_setting[id].pullup_en);
 	}
 }
 
-static void i3c_hub_of_get_configuration(struct device *dev, const struct device_node *node)
+static void i3c_hub_of_get_conf_static(struct device *dev, const struct device_node *node)
 {
 	struct i3c_hub *priv = dev_get_drvdata(dev);
-	int ret;
-
-	ret = i3c_hub_of_get_setting(node, "cp0-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
-				     &priv->settings.cp0_ldo);
-	if (ret)
-		dev_warn(dev, "Invalid or not specified setting for cp0-ldo\n");
-
-	ret = i3c_hub_of_get_setting(node, "cp1-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
-				     &priv->settings.cp1_ldo);
-	if (ret)
-		dev_warn(dev, "Invalid or not specified setting for cp1-ldo\n");
-
-	ret = i3c_hub_of_get_setting(node, "tp0145-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
-				     &priv->settings.tp0145_ldo);
-	if (ret)
-		dev_warn(dev, "Invalid or not specified setting for tp0145-ldo\n");
-
-	ret = i3c_hub_of_get_setting(node, "tp2367-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
-				     &priv->settings.tp2367_ldo);
-	if (ret)
-		dev_warn(dev, "Invalid or not specified setting for tp2367-ldo\n");
-
-	ret = i3c_hub_of_get_setting(node, "tp0145-pullup", pullup_settings,
-				     ARRAY_SIZE(pullup_settings), &priv->settings.tp0145_pullup);
-	if (ret)
-		dev_warn(dev, "Invalid or not specified setting for tp0145-pullup\n");
 
-	ret = i3c_hub_of_get_setting(node, "tp2367-pullup", pullup_settings,
-				     ARRAY_SIZE(pullup_settings), &priv->settings.tp2367_pullup);
-	if (ret)
-		dev_warn(dev, "Invalid or not specified setting for tp2367-pullup\n");
+	i3c_hub_of_get_setting(dev, node, "cp0-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
+			       &priv->settings.cp0_ldo);
+	i3c_hub_of_get_setting(dev, node, "cp1-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
+			       &priv->settings.cp1_ldo);
+	i3c_hub_of_get_setting(dev, node, "tp0145-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
+			       &priv->settings.tp0145_ldo);
+	i3c_hub_of_get_setting(dev, node, "tp2367-ldo", ldo_settings, ARRAY_SIZE(ldo_settings),
+			       &priv->settings.tp2367_ldo);
+	i3c_hub_of_get_setting(dev, node, "tp0145-pullup", pullup_settings,
+			       ARRAY_SIZE(pullup_settings), &priv->settings.tp0145_pullup);
+	i3c_hub_of_get_setting(dev, node, "tp2367-pullup", pullup_settings,
+			       ARRAY_SIZE(pullup_settings), &priv->settings.tp2367_pullup);
+	i3c_hub_of_get_setting(dev, node, "cp0-io-strength", io_strength_settings,
+			       ARRAY_SIZE(io_strength_settings), &priv->settings.cp0_io_strength);
+	i3c_hub_of_get_setting(dev, node, "cp1-io-strength", io_strength_settings,
+			       ARRAY_SIZE(io_strength_settings), &priv->settings.cp1_io_strength);
+	i3c_hub_of_get_setting(dev, node, "tp0145-io-strength", io_strength_settings,
+			       ARRAY_SIZE(io_strength_settings),
+			       &priv->settings.tp0145_io_strength);
+	i3c_hub_of_get_setting(dev, node, "tp2367-io-strength", io_strength_settings,
+			       ARRAY_SIZE(io_strength_settings),
+			       &priv->settings.tp2367_io_strength);
 
 	i3c_hub_tp_of_get_setting(dev, node, priv->settings.tp);
 }
@@ -367,6 +480,10 @@
 	priv->settings.tp2367_ldo = I3C_HUB_DT_LDO_NOT_DEFINED;
 	priv->settings.tp0145_pullup = I3C_HUB_DT_PULLUP_NOT_DEFINED;
 	priv->settings.tp2367_pullup = I3C_HUB_DT_PULLUP_NOT_DEFINED;
+	priv->settings.cp0_io_strength = I3C_HUB_DT_IO_STRENGTH_NOT_DEFINED;
+	priv->settings.cp1_io_strength = I3C_HUB_DT_IO_STRENGTH_NOT_DEFINED;
+	priv->settings.tp0145_io_strength = I3C_HUB_DT_IO_STRENGTH_NOT_DEFINED;
+	priv->settings.tp2367_io_strength = I3C_HUB_DT_IO_STRENGTH_NOT_DEFINED;
 
 	for (id = 0; id < I3C_HUB_TP_MAX_COUNT; ++id) {
 		priv->settings.tp[id].mode = I3C_HUB_DT_TP_MODE_NOT_DEFINED;
@@ -457,6 +574,48 @@
 	return regmap_update_bits(priv->regmap, I3C_HUB_LDO_AND_PULLUP_CONF, ldo_en, ldo_en);
 }
 
+static int i3c_hub_hw_configure_io_strength(struct device *dev)
+{
+	struct i3c_hub *priv = dev_get_drvdata(dev);
+	u8 mask_all = 0, val_all = 0;
+	u32 reg_val;
+	u8 val;
+	int ret;
+
+	/* Get IO strength configuration to figure out what needs to be changed */
+	ret = regmap_read(priv->regmap, I3C_HUB_IO_STRENGTH, &reg_val);
+	if (ret)
+		return ret;
+
+	if (priv->settings.cp0_io_strength != I3C_HUB_DT_IO_STRENGTH_NOT_DEFINED) {
+		val = CP0_IO_STRENGTH
+			(i3c_hub_io_strength_dt_to_reg(priv->settings.cp0_io_strength));
+		mask_all |= CP0_IO_STRENGTH_MASK;
+		val_all |= val;
+	}
+	if (priv->settings.cp1_io_strength != I3C_HUB_DT_IO_STRENGTH_NOT_DEFINED) {
+		val = CP1_IO_STRENGTH
+			(i3c_hub_io_strength_dt_to_reg(priv->settings.cp1_io_strength));
+		mask_all |= CP1_IO_STRENGTH_MASK;
+		val_all |= val;
+	}
+	if (priv->settings.tp0145_io_strength != I3C_HUB_DT_IO_STRENGTH_NOT_DEFINED) {
+		val = TP0145_IO_STRENGTH
+			(i3c_hub_io_strength_dt_to_reg(priv->settings.tp0145_io_strength));
+		mask_all |= TP0145_IO_STRENGTH_MASK;
+		val_all |= val;
+	}
+	if (priv->settings.tp2367_io_strength != I3C_HUB_DT_IO_STRENGTH_NOT_DEFINED) {
+		val = TP2367_IO_STRENGTH
+			(i3c_hub_io_strength_dt_to_reg(priv->settings.tp2367_io_strength));
+		mask_all |= TP2367_IO_STRENGTH_MASK;
+		val_all |= val;
+	}
+
+	/* Set IO strength if required */
+	return regmap_update_bits(priv->regmap, I3C_HUB_IO_STRENGTH, mask_all, val_all);
+}
+
 static int i3c_hub_hw_configure_tp(struct device *dev)
 {
 	struct i3c_hub *priv = dev_get_drvdata(dev);
@@ -488,7 +647,11 @@
 		}
 	}
 
-	ret = regmap_update_bits(priv->regmap, I3C_HUB_TP_NET_CON_CONF, i3c_mask, i3c_val);
+	ret = regmap_update_bits(priv->regmap, I3C_HUB_TP_IO_MODE_CONF, smbus_mask, smbus_val);
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(priv->regmap, I3C_HUB_TP_PULLUP_EN, pullup_mask, pullup_val);
 	if (ret)
 		return ret;
 
@@ -500,35 +663,125 @@
 	if (ret)
 		return ret;
 
+	/* Request for HUB Network connection in case any TP is configured in I3C mode */
+	if (i3c_val) {
+		ret = regmap_write(priv->regmap, I3C_HUB_CP_MUX_SET, CONTROLLER_PORT_MUX_REQ);
+		if (ret)
+			return ret;
+		/* TODO: verify if connection is done */
+	}
+
 	/* Enable TP here in case TP was configured */
 	ret = regmap_update_bits(priv->regmap, I3C_HUB_TP_ENABLE, i3c_mask | smbus_mask | gpio_mask,
 				 i3c_val | smbus_val | gpio_val);
 	if (ret)
 		return ret;
 
-	return regmap_update_bits(priv->regmap, I3C_HUB_TP_PULLUP_EN, pullup_mask, pullup_val);
+	return regmap_update_bits(priv->regmap, I3C_HUB_TP_NET_CON_CONF, i3c_mask, i3c_val);
 }
 
 static int i3c_hub_configure_hw(struct device *dev)
 {
 	int ret;
 
-	ret = i3c_hub_hw_configure_pullup(dev);
+	ret = i3c_hub_hw_configure_ldo(dev);
 	if (ret)
 		return ret;
 
-	ret = i3c_hub_hw_configure_ldo(dev);
+	ret = i3c_hub_hw_configure_io_strength(dev);
+	if (ret)
+		return ret;
+
+	ret = i3c_hub_hw_configure_pullup(dev);
 	if (ret)
 		return ret;
 
 	return i3c_hub_hw_configure_tp(dev);
 }
 
+static void i3c_hub_of_get_conf_runtime(struct device *dev, const struct device_node *node)
+{
+	struct i3c_hub *priv = dev_get_drvdata(dev);
+	struct device_node *i3c_node;
+	int i3c_id;
+	u8 tp_mask;
+
+	for_each_available_child_of_node(node, i3c_node) {
+		if (!i3c_node->full_name ||
+		    (sscanf(i3c_node->full_name, "i3c%i@%hhx", &i3c_id, &tp_mask) != 2)) {
+			continue;
+		}
+
+		if (i3c_id < I3C_HUB_LOGICAL_BUS_MAX_COUNT) {
+			priv->logical_bus[i3c_id].available = true;
+			priv->logical_bus[i3c_id].of_node = i3c_node;
+			priv->logical_bus[i3c_id].tp_map = tp_mask;
+			priv->logical_bus[i3c_id].priv = priv;
+		}
+	}
+}
+
 static const struct i3c_device_id i3c_hub_ids[] = {
 	I3C_CLASS(I3C_DCR_HUB, NULL),
 	{ },
 };
 
+static int i3c_hub_read_id(struct device *dev)
+{
+	struct i3c_hub *priv = dev_get_drvdata(dev);
+	u32 reg_val;
+	int ret;
+
+	ret = regmap_read(priv->regmap, I3C_HUB_LDO_AND_CPSEL_STS, &reg_val);
+	if (ret) {
+		dev_err(dev, "Failed to read status register\n");
+		return -1;
+	}
+
+	priv->hub_pin_sel_id = CP_SEL_PIN_INPUT_CODE_GET(reg_val);
+	priv->hub_pin_cp1_id = CP_SDA1_SCL1_PINS_CODE_GET(reg_val);
+	return 0;
+}
+
+static struct device_node *i3c_hub_get_dt_hub_node(struct device_node *node,
+						   struct i3c_hub *priv)
+{
+	struct device_node *hub_node_no_id = NULL;
+	struct device_node *hub_node;
+	u32 hub_id;
+	int found_id = 0;
+
+	for_each_available_child_of_node(node, hub_node) {
+		if (strstr(hub_node->name, "hub")) {
+			if (!of_property_read_u32(hub_node, "id", &hub_id)) {
+				if (hub_id == (u32)priv->hub_pin_sel_id)
+					found_id = 1;
+				priv->hub_dt_sel_id = hub_id;
+			}
+
+			if (!of_property_read_u32(hub_node, "id-cp1", &hub_id)) {
+				if (hub_id == (u32)priv->hub_pin_cp1_id)
+					found_id = 1;
+				priv->hub_dt_cp1_id = hub_id;
+			}
+
+			if (!found_id) {
+				/*
+				 * Just keep reference to first HUB node with no ID in case no ID
+				 * matching
+				 */
+				if (!hub_node_no_id && priv->hub_dt_sel_id == -1 &&
+				    priv->hub_dt_cp1_id == -1)
+					hub_node_no_id = hub_node;
+			} else {
+				return hub_node;
+			}
+		}
+	}
+
+	return hub_node_no_id;
+}
+
 static int fops_access_reg_get(void *ctx, u64 *val)
 {
 	struct i3c_hub *priv = ctx;
@@ -603,6 +856,723 @@
 	return PTR_ERR(entry);
 }
 
+static void i3c_hub_trans_pre_cb(struct i3c_master_controller *controller)
+{
+	struct logical_bus *bus = container_of(controller, struct logical_bus, controller);
+	struct i3c_hub *priv = bus->priv;
+	struct device *dev = i3cdev_to_dev(priv->i3cdev);
+	int ret;
+
+	ret = regmap_write(priv->regmap, I3C_HUB_TP_NET_CON_CONF, bus->tp_map);
+	if (ret)
+		dev_warn(dev, "Failed to open Target Port(s)\n");
+}
+
+static void i3c_hub_trans_post_cb(struct i3c_master_controller *controller)
+{
+	struct logical_bus *bus = container_of(controller, struct logical_bus, controller);
+	struct i3c_hub *priv = bus->priv;
+	struct device *dev = i3cdev_to_dev(priv->i3cdev);
+	int ret;
+
+	ret = regmap_write(priv->regmap, I3C_HUB_TP_NET_CON_CONF, 0x00);
+	if (ret)
+		dev_warn(dev, "Failed to close Target Port(s)\n");
+}
+
+static struct logical_bus *bus_from_i3c_desc(struct i3c_dev_desc *desc)
+{
+	struct i3c_master_controller *controller = i3c_dev_get_master(desc);
+
+	return container_of(controller, struct logical_bus, controller);
+}
+
+static struct i3c_master_controller
+	*parent_from_controller(struct i3c_master_controller *controller)
+{
+	struct logical_bus *bus = container_of(controller, struct logical_bus, controller);
+
+	return bus->priv->controller;
+}
+
+static struct i3c_master_controller *parent_controller_from_i3c_desc(struct i3c_dev_desc *desc)
+{
+	struct i3c_master_controller *controller = i3c_dev_get_master(desc);
+	struct logical_bus *bus = container_of(controller, struct logical_bus, controller);
+
+	return bus->priv->controller;
+}
+
+static struct i3c_master_controller *parent_controller_from_i2c_desc(struct i2c_dev_desc *desc)
+{
+	struct i3c_master_controller *controller = desc->common.master;
+	struct logical_bus *bus = container_of(controller, struct logical_bus, controller);
+
+	return bus->priv->controller;
+}
+
+static int i3c_hub_read_transaction_status(struct i3c_hub *priv,
+					   u8 target_port_status,
+					   u8 *status)
+{
+	unsigned long time_to_timeout = 0;
+	unsigned int status_read;
+	ktime_t start, end;
+	int ret;
+
+	start = ktime_get_real();
+
+	while (time_to_timeout < (long)I3C_HUB_SMBUS_400kHz_TIMEOUT) {
+		ret = regmap_read(priv->regmap, target_port_status, &status_read);
+		if (ret)
+			return ret;
+
+		*status = (u8)status_read;
+
+		if ((*status & I3C_HUB_TP_BUFFER_STATUS_MASK) == I3C_HUB_XFER_SUCCESS)
+			return 0;
+
+		if (!(*status & I3C_HUB_TP_BUFFER_STATUS_MASK) &&
+			(*status & I3C_HUB_TP_TRANSACTION_CODE_MASK)) {
+			dev_err(&priv->i3cdev->dev, "Invalid transfer status returned\n");
+			return 0;
+		}
+
+		end = ktime_get_real();
+		time_to_timeout = end - start;
+	}
+	dev_err(&priv->i3cdev->dev, "Status read timeout reached\n");
+	return 0;
+}
+
+/*
+ * i3c_hub_smbus_msg() - This starts a smbus write transaction by writing a descriptor
+ * and a message to the hub registers. Controller buffer page is determined by multiplying the
+ * target port index by four and adding the base page number to it.
+ * @priv: a pointer to the i3c hub main structure
+ * @ssport: a number of the port where the transaction will happen
+ * @xfers: i2c_msg struct received from the master_xfers callback
+ * @nxfers_i: the number of the current message
+ * @rw: number informing if the message is of read or write type (0 for write, 1 for read)
+ * @return_status: number passed by reference where the return status code is saved
+ *
+ * Return: on success function returns zero. Otherwise the regmap read or write error code
+ * is returned
+ */
+static int i3c_hub_smbus_msg(struct i3c_hub *priv,
+			     struct i2c_msg *xfers,
+			     u8 target_port,
+			     u8 nxfers_i,
+			     u8 rw,
+			     u8 *return_status)
+{
+	u8 transaction_type = I3C_HUB_SMBUS_400kHz;
+	u8 controller_buffer_page = I3C_HUB_CONTROLLER_BUFFER_PAGE + 4 * target_port;
+	int write_length = xfers[nxfers_i].len;
+	int read_length = xfers[nxfers_i].len;
+	u8 target_port_status = I3C_HUB_TP0_SMBUS_AGNT_STS + target_port;
+	u8 addr = xfers[nxfers_i].addr;
+	u8 target_port_code = BIT(target_port);
+	u8 rw_address = 2 * addr;
+	u8 desc[I3C_HUB_SMBUS_DESCRIPTOR_SIZE] = {0};
+	u8 status;
+	int ret;
+
+	if (rw)
+		rw_address |= BIT(0);
+	else
+		read_length = 0;
+
+	desc[0] = rw_address;
+	desc[1] = transaction_type;
+	desc[2] = write_length;
+	desc[3] = read_length;
+
+	ret = regmap_write(priv->regmap, target_port_status, I3C_HUB_TP_BUFFER_STATUS_MASK);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(priv->regmap, I3C_HUB_PAGE_PTR, controller_buffer_page);
+	if (ret)
+		return ret;
+
+	ret = regmap_bulk_write(priv->regmap,
+				I3C_HUB_CONTROLLER_AGENT_BUFF,
+				desc,
+				I3C_HUB_SMBUS_DESCRIPTOR_SIZE);
+	if (ret)
+		return ret;
+
+	if (!rw) {
+		ret = regmap_bulk_write(priv->regmap,
+					I3C_HUB_CONTROLLER_AGENT_BUFF_DATA,
+					xfers[nxfers_i].buf,
+					xfers[nxfers_i].len);
+		if (ret)
+			return ret;
+	}
+
+	ret = regmap_write(priv->regmap, I3C_HUB_TP_SMBUS_AGNT_TRANS_START, target_port_code);
+	if (ret)
+		return ret;
+
+	ret = i3c_hub_read_transaction_status(priv, target_port_status, &status);
+	if (ret)
+		return ret;
+
+	*return_status = status;
+
+	if (rw) {
+		ret = regmap_bulk_read(priv->regmap,
+				       I3C_HUB_CONTROLLER_AGENT_BUFF_DATA,
+				       xfers[nxfers_i].buf,
+				       xfers[nxfers_i].len);
+		if (ret)
+			return ret;
+	}
+
+	ret = regmap_write(priv->regmap, I3C_HUB_PAGE_PTR, 0x00);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/**
+ * i3c_controller_smbus_port_adapter_xfer() - i3c hub smbus transfer logic
+ * @adap: i2c_adapter corresponding with single port in the i3c hub
+ * @xfers: all messages descriptors and data
+ * @nxfers: amount of single messages in a transfer
+ *
+ * Return: function returns the sum of correctly sent messages (only those with hub return
+ * status 0x01)
+ */
+static int i3c_controller_smbus_port_adapter_xfer(struct i2c_adapter *adap,
+						  struct i2c_msg *xfers,
+						  int nxfers)
+{
+	struct i3c_master_controller *controller =
+		container_of(adap, struct i3c_master_controller, i2c);
+	struct logical_bus *bus =
+		container_of(controller, struct logical_bus, controller);
+	struct i3c_hub *priv = bus->priv;
+	int ret_sum = 0;
+	int ret;
+	u8 return_status;
+	u8 nxfers_i;
+	u8 rw;
+
+	for (nxfers_i = 0 ; nxfers_i < nxfers ; nxfers_i++) {
+		if (xfers[nxfers_i].len > I3C_HUB_SMBUS_PAYLOAD_SIZE) {
+			dev_err(&adap->dev,
+				"Message nr. %d not sent - length over %d bytes.\n",
+				nxfers_i,
+				I3C_HUB_SMBUS_PAYLOAD_SIZE);
+			continue;
+		}
+
+		rw = xfers[nxfers_i].flags % 2;
+
+		ret = i3c_hub_smbus_msg(priv,
+					xfers,
+					bus->smbus_port_adapter.tp_port,
+					nxfers_i,
+					rw,
+					&return_status);
+		if (ret)
+			return ret;
+		if (return_status == I3C_HUB_XFER_SUCCESS)
+			ret_sum++;
+	}
+	return ret_sum;
+}
+
+static int i3c_hub_bus_init(struct i3c_master_controller *controller)
+{
+	struct logical_bus *bus = container_of(controller, struct logical_bus, controller);
+
+	controller->this = bus->priv->i3cdev->desc;
+	return 0;
+}
+
+static void i3c_hub_bus_cleanup(struct i3c_master_controller *controller)
+{
+	controller->this = NULL;
+}
+
+static int i3c_hub_attach_i3c_dev(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i3c_desc(dev);
+
+	return parent->ops->attach_i3c_dev(dev);
+}
+
+static int i3c_hub_reattach_i3c_dev(struct i3c_dev_desc *dev, u8 old_dyn_addr)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i3c_desc(dev);
+
+	return parent->ops->reattach_i3c_dev(dev, old_dyn_addr);
+}
+
+static void i3c_hub_detach_i3c_dev(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i3c_desc(dev);
+
+	parent->ops->detach_i3c_dev(dev);
+}
+
+static int i3c_hub_do_daa(struct i3c_master_controller *controller)
+{
+	struct i3c_master_controller *parent = parent_from_controller(controller);
+
+	return parent->ops->do_daa(controller);
+}
+
+static bool i3c_hub_supports_ccc_cmd(struct i3c_master_controller *controller,
+				     const struct i3c_ccc_cmd *cmd)
+{
+	struct i3c_master_controller *parent = parent_from_controller(controller);
+
+	return parent->ops->supports_ccc_cmd(controller, cmd);
+}
+
+static int i3c_hub_send_ccc_cmd(struct i3c_master_controller *controller, struct i3c_ccc_cmd *cmd)
+{
+	struct i3c_master_controller *parent = parent_from_controller(controller);
+
+	return parent->ops->send_ccc_cmd(controller, cmd);
+}
+
+static int i3c_hub_priv_xfers(struct i3c_dev_desc *dev, struct i3c_priv_xfer *xfers, int nxfers)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i3c_desc(dev);
+	struct logical_bus *bus = bus_from_i3c_desc(dev);
+	int res;
+
+	i3c_hub_trans_pre_cb(&bus->controller);
+	res = parent->ops->priv_xfers(dev, xfers, nxfers);
+	i3c_hub_trans_post_cb(&bus->controller);
+
+	return res;
+}
+
+static int i3c_hub_attach_i2c_dev(struct i2c_dev_desc *dev)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i2c_desc(dev);
+
+	return parent->ops->attach_i2c_dev(dev);
+}
+
+static void i3c_hub_detach_i2c_dev(struct i2c_dev_desc *dev)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i2c_desc(dev);
+
+	parent->ops->detach_i2c_dev(dev);
+}
+
+static int i3c_hub_i2c_xfers(struct i2c_dev_desc *dev, const struct i2c_msg *xfers, int nxfers)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i2c_desc(dev);
+
+	return parent->ops->i2c_xfers(dev, xfers, nxfers);
+}
+
+static int i3c_hub_request_ibi(struct i3c_dev_desc *dev, const struct i3c_ibi_setup *req)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i3c_desc(dev);
+
+	return parent->ops->request_ibi(dev, req);
+}
+
+static void i3c_hub_free_ibi(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i3c_desc(dev);
+
+	parent->ops->free_ibi(dev);
+}
+
+static int i3c_hub_enable_ibi(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i3c_desc(dev);
+
+	return parent->ops->enable_ibi(dev);
+}
+
+static int i3c_hub_disable_ibi(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i3c_desc(dev);
+
+	return parent->ops->disable_ibi(dev);
+}
+
+static void i3c_hub_recycle_ibi_slot(struct i3c_dev_desc *dev, struct i3c_ibi_slot *slot)
+{
+	struct i3c_master_controller *parent = parent_controller_from_i3c_desc(dev);
+
+	return parent->ops->recycle_ibi_slot(dev, slot);
+}
+
+static const struct i3c_master_controller_ops i3c_hub_i3c_ops = {
+	.bus_init = i3c_hub_bus_init,
+	.bus_cleanup = i3c_hub_bus_cleanup,
+	.attach_i3c_dev = i3c_hub_attach_i3c_dev,
+	.reattach_i3c_dev = i3c_hub_reattach_i3c_dev,
+	.detach_i3c_dev = i3c_hub_detach_i3c_dev,
+	.do_daa = i3c_hub_do_daa,
+	.supports_ccc_cmd = i3c_hub_supports_ccc_cmd,
+	.send_ccc_cmd = i3c_hub_send_ccc_cmd,
+	.priv_xfers = i3c_hub_priv_xfers,
+	.attach_i2c_dev = i3c_hub_attach_i2c_dev,
+	.detach_i2c_dev = i3c_hub_detach_i2c_dev,
+	.i2c_xfers = i3c_hub_i2c_xfers,
+	.request_ibi = i3c_hub_request_ibi,
+	.free_ibi = i3c_hub_free_ibi,
+	.enable_ibi = i3c_hub_enable_ibi,
+	.disable_ibi = i3c_hub_disable_ibi,
+	.recycle_ibi_slot = i3c_hub_recycle_ibi_slot,
+};
+
+/* SMBus virtual i3c_master_controller_ops */
+
+static int i3c_hub_do_daa_smbus(struct i3c_master_controller *controller)
+{
+	return 0;
+}
+
+static int i3c_hub_send_ccc_cmd_smbus(struct i3c_master_controller *controller,
+				      struct i3c_ccc_cmd *cmd)
+{
+	return 0;
+}
+
+static int i3c_hub_priv_xfers_smbus(struct i3c_dev_desc *dev,
+				    struct i3c_priv_xfer *xfers,
+				    int nxfers)
+{
+	return 0;
+}
+
+static int i3c_hub_i2c_xfers_smbus(struct i2c_dev_desc *dev,
+				   const struct i2c_msg *xfers,
+				   int nxfers)
+{
+	return 0;
+}
+
+static const struct i3c_master_controller_ops i3c_hub_i3c_ops_smbus = {
+	.bus_init = i3c_hub_bus_init,
+	.bus_cleanup = i3c_hub_bus_cleanup,
+	.do_daa = i3c_hub_do_daa_smbus,
+	.send_ccc_cmd = i3c_hub_send_ccc_cmd_smbus,
+	.priv_xfers = i3c_hub_priv_xfers_smbus,
+	.i2c_xfers = i3c_hub_i2c_xfers_smbus,
+};
+
+int i3c_hub_logic_register(struct i3c_master_controller *controller,
+			   struct i3c_master_controller *top_controller, struct device *parent)
+{
+	controller->bus_driver_context = top_controller->bus_driver_context;
+	return i3c_master_register(controller, parent, &i3c_hub_i3c_ops, false);
+}
+
+int i3c_hub_logic_register_smbus(struct i3c_master_controller *controller,
+				 struct i3c_master_controller *top_controller,
+				 struct device *parent)
+{
+	controller->bus_driver_context = top_controller->bus_driver_context;
+	return i3c_master_register(controller, parent, &i3c_hub_i3c_ops_smbus, false);
+}
+
+static u32 i3c_controller_smbus_funcs(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;
+}
+
+static int reg_i2c_target(struct i2c_client *client)
+{
+	return 0;
+}
+
+static int unreg_i2c_target(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_algorithm i3c_controller_smbus_algo = {
+	.master_xfer = i3c_controller_smbus_port_adapter_xfer,
+	.functionality = i3c_controller_smbus_funcs,
+	.reg_slave = reg_i2c_target,
+	.unreg_slave = unreg_i2c_target,
+};
+
+static void i3c_hub_delayed_work(struct work_struct *work)
+{
+	struct i3c_hub *priv = container_of(work, typeof(*priv), delayed_work.work);
+	struct device *dev = i3cdev_to_dev(priv->i3cdev);
+	struct i2c_board_info host_notify_board_info;
+	int ret;
+	int i;
+
+	for (i = 0; i < I3C_HUB_LOGICAL_BUS_MAX_COUNT; ++i) {
+		if (priv->logical_bus[i].available) {
+			ret = regmap_write(priv->regmap, I3C_HUB_TP_NET_CON_CONF,
+					   priv->logical_bus[i].tp_map);
+			if (ret)
+				dev_warn(dev, "Failed to open Target Port(s)\n");
+
+			dev->of_node = priv->logical_bus[i].of_node;
+			ret = i3c_hub_logic_register(&priv->logical_bus[i].controller,
+						     i3c_dev_get_master(priv->i3cdev->desc), dev);
+			if (ret)
+				dev_warn(dev, "Failed to register i3c controller - bus id:%i\n", i);
+			else
+				priv->logical_bus[i].registered = true;
+
+			ret = regmap_write(priv->regmap, I3C_HUB_TP_NET_CON_CONF, 0x00);
+			if (ret)
+				dev_warn(dev, "Failed to close Target Port(s)\n");
+		}
+	}
+
+	ret = i3c_master_do_daa(priv->controller);
+	if (ret)
+		dev_warn(dev, "Failed to run DAA\n");
+
+	for (i = 0 ; i < I3C_HUB_TP_MAX_COUNT ; i++) {
+		if (!priv->logical_bus[i].smbus_port_adapter.used)
+			continue;
+
+		priv->logical_bus[i].controller.i2c.algo = &i3c_controller_smbus_algo;
+
+		if (!priv->logical_bus[i].smbus_port_adapter.compatible)
+			continue;
+
+		host_notify_board_info.addr = priv->logical_bus[i].smbus_port_adapter.addr;
+		host_notify_board_info.flags = I2C_CLIENT_SLAVE;
+		snprintf(host_notify_board_info.type,
+			 I2C_NAME_SIZE,
+			 priv->logical_bus[i].smbus_port_adapter.compatible);
+
+		priv->logical_bus[i].smbus_port_adapter.client =
+			i2c_new_client_device(&priv->logical_bus[i].controller.i2c,
+					      &host_notify_board_info);
+		if (IS_ERR(priv->logical_bus[i].smbus_port_adapter.client)) {
+			dev_warn(dev, "Error while registering backend\n");
+			return;
+		}
+
+		schedule_delayed_work(&priv->logical_bus[i].smbus_port_adapter.delayed_work_polling,
+					msecs_to_jiffies(I3C_HUB_POLLING_ROLL_PERIOD_MS));
+	}
+}
+
+static int i3c_hub_register_smbus_controller(struct i3c_hub *priv, int i)
+{
+	struct device *dev = i3cdev_to_dev(priv->i3cdev);
+	int ret;
+
+	ret = regmap_write(priv->regmap,
+			   I3C_HUB_TP_NET_CON_CONF,
+			   priv->logical_bus[i].smbus_port_adapter.tp_mask);
+	if (ret) {
+		dev_warn(dev, "Failed to open Target Port");
+		return ret;
+	}
+
+	ret = i3c_hub_logic_register_smbus(&priv->logical_bus[i].controller,
+					   priv->controller, dev);
+	if (ret) {
+		dev_warn(dev, "Failed to register i3c controller\n");
+		return ret;
+	}
+
+	ret = regmap_write(priv->regmap, I3C_HUB_TP_NET_CON_CONF, 0x00);
+	if (ret) {
+		dev_warn(dev, "Failed to close Target Port");
+		return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * i3c_hub_delayed_work_polling() - This delayed work is a polling mechanism to
+ * find if any transaction happened. After a transaction was found it is saved with
+ * the slave-mqueue backend and can be read from the fs. Controller buffer page is
+ * determined by adding the first buffer page number to port index multiplied by four.
+ * The two target buffer page numbers are determined the same way but they are offset
+ * by 2 and 3 from the controller page.
+ */
+static void i3c_hub_delayed_work_polling(struct work_struct *work)
+{
+	struct i2c_adapter_group *g_adap = container_of(work,
+							typeof(*g_adap),
+							delayed_work_polling.work);
+	struct logical_bus *bus = container_of(g_adap, struct logical_bus, smbus_port_adapter);
+	u8 controller_buffer_page = I3C_HUB_CONTROLLER_BUFFER_PAGE + 4 * g_adap->tp_port;
+	u8 target_port_status = I3C_HUB_TP0_SMBUS_AGNT_STS + g_adap->tp_port;
+	u8 local_buffer[I3C_HUB_SMBUS_TARGET_PAYLOAD_SIZE] = {0};
+	u8 target_buffer_page, address, test, len, tmp;
+	struct i3c_hub *priv = bus->priv;
+	struct device *dev = i3cdev_to_dev(priv->i3cdev);
+	u32 local_last_status, i;
+
+	regmap_read(priv->regmap, target_port_status, &local_last_status);
+
+	tmp = local_last_status;
+	if (tmp & I3C_HUB_TARGET_BUF_OVRFL) {
+		regmap_write(priv->regmap, I3C_HUB_PAGE_PTR, 0x00);
+		regmap_write(priv->regmap, target_port_status, I3C_HUB_TP_BUFFER_STATUS_MASK);
+		regmap_read(priv->regmap, target_port_status, &local_last_status);
+		g_adap->polling_last_status = local_last_status;
+	} else if (local_last_status != g_adap->polling_last_status) {
+		if (tmp & I3C_HUB_TARGET_BUF_0_RECEIVE)
+			target_buffer_page = controller_buffer_page + 2;
+		else if (tmp & I3C_HUB_TARGET_BUF_1_RECEIVE)
+			target_buffer_page = controller_buffer_page + 3;
+		else
+			goto reschedule;
+
+		regmap_write(priv->regmap, I3C_HUB_PAGE_PTR, target_buffer_page);
+
+		regmap_read(priv->regmap, I3C_HUB_TARGET_BUFF_LENGTH, &local_last_status);
+
+		len = local_last_status - 1;
+		if (len > I3C_HUB_SMBUS_TARGET_PAYLOAD_SIZE) {
+			dev_err(dev, "Received message too big for hub buffer\n");
+			goto reschedule;
+		}
+
+		regmap_read(priv->regmap, I3C_HUB_TARGET_BUFF_ADDRESS, &local_last_status);
+
+		address = local_last_status;
+		if ((address >> 1) != g_adap->addr)
+			goto reschedule;
+
+		regmap_bulk_read(priv->regmap, I3C_HUB_TARGET_BUFF_DATA, local_buffer, len);
+
+		i2c_slave_event(g_adap->client, I2C_SLAVE_WRITE_RECEIVED, &address);
+
+		for (i = 0 ; i < len ; i++) {
+			tmp = local_buffer[i];
+			i2c_slave_event(g_adap->client, I2C_SLAVE_WRITE_RECEIVED, &tmp);
+		}
+		i2c_slave_event(g_adap->client, I2C_SLAVE_STOP, &test);
+
+reschedule:
+		regmap_write(priv->regmap, I3C_HUB_PAGE_PTR, 0x00);
+		regmap_write(priv->regmap, target_port_status, I3C_HUB_TP_BUFFER_STATUS_MASK);
+		regmap_read(priv->regmap, target_port_status, &local_last_status);
+		g_adap->polling_last_status = local_last_status;
+	}
+
+	schedule_delayed_work(&g_adap->delayed_work_polling,
+			      msecs_to_jiffies(I3C_HUB_POLLING_ROLL_PERIOD_MS));
+}
+
+static int i3c_hub_smbus_tp_algo(struct i3c_hub *priv, int i)
+{
+	int ret;
+
+	if (priv->hub_dt_cp1_id != priv->hub_pin_cp1_id)
+		return 1;
+
+	priv->logical_bus[i].priv = priv;
+	priv->logical_bus[i].smbus_port_adapter.tp_port = i;
+	priv->logical_bus[i].smbus_port_adapter.tp_mask = BIT(i);
+
+	/* Register controller for target port*/
+	ret = i3c_hub_register_smbus_controller(priv, i);
+	if (ret)
+		return ret;
+
+	priv->logical_bus[i].smbus_port_adapter.used = 1;
+
+	INIT_DELAYED_WORK(&priv->logical_bus[i].smbus_port_adapter.delayed_work_polling,
+			  i3c_hub_delayed_work_polling);
+
+	priv->logical_bus[i].controller.i2c.dev.parent =
+		priv->logical_bus[i].controller.dev.parent;
+	priv->logical_bus[i].controller.i2c.owner =
+		priv->logical_bus[i].controller.dev.parent->driver->owner;
+
+	sprintf(priv->logical_bus[i].controller.i2c.name, "hub0x%X.port%d",
+		priv->hub_dt_cp1_id, i);
+
+	priv->logical_bus[i].controller.i2c.timeout = 1000;
+	priv->logical_bus[i].controller.i2c.retries = 3;
+
+	return 0;
+}
+
+static int read_backend_from_i3c_hub_dts(struct device_node *i3c_node_target,
+					 struct i3c_hub *priv)
+{
+	struct device_node *i3c_node_tp;
+	const char *compatible;
+	int tp_port, ret;
+	u32 addr_dts;
+
+	if (sscanf(i3c_node_target->full_name, "target-port@%d", &tp_port) == 0)
+		return -EINVAL;
+
+	if (tp_port > I3C_HUB_TP_MAX_COUNT)
+		return -ERANGE;
+
+	if (tp_port < 0)
+		return -EINVAL;
+
+	for_each_available_child_of_node(i3c_node_target, i3c_node_tp) {
+		if (strcmp(i3c_node_tp->full_name, "backend@0,0"))
+			continue;
+
+		ret = of_property_read_u32(i3c_node_tp, "target_reg", &addr_dts);
+		if (ret)
+			return ret;
+
+		ret = of_property_read_string(i3c_node_tp, "compatible", &compatible);
+		if (ret)
+			return ret;
+
+		/* Currently only the slave-mqueue backend is supported */
+		if (strcmp("slave-mqueue", compatible))
+			return -EINVAL;
+
+		priv->logical_bus[tp_port].smbus_port_adapter.addr = addr_dts;
+		priv->logical_bus[tp_port].smbus_port_adapter.compatible = compatible;
+
+		break;
+	}
+	return 0;
+}
+
+/**
+ * This function saves information about the i3c_hub's ports
+ * working in slave mode. It takes its data from the DTs
+ * (aspeed-bmc-intel-avc.dts) and saves the parameters
+ * into the coresponding target port i2c_adapter_group structure
+ * in the i3c_hub
+ *
+ * @dev: device used by i3c_hub
+ * @i3c_node_hub: device node pointing to the hub
+ * @priv: pointer to the i3c_hub structure
+ */
+static void i3c_hub_parse_dt_tp(struct device *dev,
+				const struct device_node *i3c_node_hub,
+				struct i3c_hub *priv)
+{
+	struct device_node *i3c_node_target;
+	int ret;
+
+	for_each_available_child_of_node(i3c_node_hub, i3c_node_target) {
+		if (!strcmp(i3c_node_target->name, "target-port")) {
+			ret = read_backend_from_i3c_hub_dts(i3c_node_target, priv);
+			if (ret)
+				dev_err(dev, "DTS entry invalid - error %d", ret);
+		}
+	}
+}
+
 static int i3c_hub_probe(struct i3c_device *i3cdev)
 {
 	struct regmap_config i3c_hub_regmap_config = {
@@ -610,24 +1580,28 @@
 		.val_bits = 8,
 	};
 	struct device *dev = &i3cdev->dev;
-	struct device_node *node;
+	struct device_node *node = NULL;
 	struct regmap *regmap;
 	struct i3c_hub *priv;
 	char hub_id[32];
 	int ret;
+	int i;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
 	priv->i3cdev = i3cdev;
+	priv->controller = i3c_dev_get_master(i3cdev->desc);
 	i3cdev_set_drvdata(i3cdev, priv);
-
-	sprintf(hub_id, "i3c-hub-%d-%llx", i3cdev->bus->id, i3cdev->desc->info.pid);
+	INIT_DELAYED_WORK(&priv->delayed_work, i3c_hub_delayed_work);
+	sprintf(hub_id, "i3c-hub-%d-%llx", i3c_dev_get_master(i3cdev->desc)->bus_id,
+		i3cdev->desc->info.pid);
 	ret = i3c_hub_debugfs_init(priv, hub_id);
-	if (ret)
-		return dev_err_probe(dev, ret, "Failed to initialized DebugFS.\n");
-
+	if (ret){
+		dev_err(dev, "Failed to initialized DebugFS.\n");
+		return ret;
+	}
 	i3c_hub_of_default_configuration(dev);
 
 	/* TBD: Support for multiple HUBs. */
@@ -636,7 +1610,7 @@
 	if (!node) {
 		dev_warn(dev, "Failed to find DT entry for the driver. Running with defaults.\n");
 	} else {
-		i3c_hub_of_get_configuration(dev, node);
+		i3c_hub_of_get_conf_static(dev, node);
 		of_node_put(node);
 	}
 
@@ -646,9 +1620,30 @@
 		dev_err(dev, "Failed to register I3C HUB regmap\n");
 		goto error;
 	}
-
 	priv->regmap = regmap;
 
+	ret = i3c_hub_read_id(dev);
+	if (ret)
+		goto error;
+
+	priv->hub_dt_sel_id = -1;
+	priv->hub_dt_cp1_id = -1;
+	if (priv->hub_pin_cp1_id >= 0 && priv->hub_pin_sel_id >= 0)
+		/* Find hub node in DT matching HW ID or just first without ID provided in DT */
+		node = i3c_hub_get_dt_hub_node(dev->parent->of_node, priv);
+
+	if (!node) {
+		dev_info(dev, "No DT entry - running with hardware defaults.\n");
+	} else {
+		of_node_get(node);
+		i3c_hub_of_get_conf_static(dev, node);
+		i3c_hub_of_get_conf_runtime(dev, node);
+		of_node_put(node);
+
+		/* Parse DTS to find data on the SMBus target mode */
+		i3c_hub_parse_dt_tp(dev, node, priv);
+	}
+
 	/* Unlock access to protected registers */
 	ret = regmap_write(priv->regmap, I3C_HUB_PROTECTION_CODE, REGISTERS_UNLOCK_CODE);
 	if (ret) {
@@ -656,6 +1651,13 @@
 		goto error;
 	}
 
+	/* Register logic for native smbus ports */
+	for (i = 0 ; i < I3C_HUB_TP_MAX_COUNT ; i++) {
+		priv->logical_bus[i].smbus_port_adapter.used = 0;
+		if (priv->settings.tp[i].mode == I3C_HUB_DT_TP_MODE_SMBUS)
+			ret = i3c_hub_smbus_tp_algo(priv, i);
+	}
+
 	ret = i3c_hub_configure_hw(dev);
 	if (ret) {
 		dev_err(dev, "Failed to configure the HUB\n");
@@ -671,6 +1673,8 @@
 
 	/* TBD: Apply special/security lock here using DEV_CMD register */
 
+	schedule_delayed_work(&priv->delayed_work, msecs_to_jiffies(100));
+
 	return 0;
 
 error:
@@ -681,7 +1685,21 @@
 static void i3c_hub_remove(struct i3c_device *i3cdev)
 {
 	struct i3c_hub *priv = i3cdev_get_drvdata(i3cdev);
+	struct i2c_adapter_group *g_adap;
+	int i;
+
+	for (i = 0; i < I3C_HUB_TP_MAX_COUNT ; i++) {
+		if (priv->logical_bus[i].smbus_port_adapter.used) {
+			g_adap = &priv->logical_bus[i].smbus_port_adapter;
+			cancel_delayed_work_sync(&g_adap->delayed_work_polling);
+			i2c_unregister_device(g_adap->client);
+		}
+
+		if (priv->logical_bus[i].smbus_port_adapter.used || priv->logical_bus[i].registered)
+			i3c_master_unregister(&priv->logical_bus[i].controller);
+	}
 
+	cancel_delayed_work_sync(&priv->delayed_work);
 	debugfs_remove_recursive(priv->debug_dir);
 }
 
diff -Naur linux_org/drivers/i3c/internals.h linux/drivers/i3c/internals.h
--- linux_org/drivers/i3c/internals.h	2024-02-06 01:18:16.243869582 +0800
+++ linux/drivers/i3c/internals.h	2024-02-15 01:32:08.000000000 +0800
@@ -37,5 +37,7 @@
 			     struct i3c_device_info *info, u16 write_len);
 int i3c_for_each_dev(void *data, int (*fn)(struct device *, void *));
 int i3c_dev_generate_ibi_locked(struct i3c_dev_desc *dev, const u8 *data, int len);
+int i3c_dev_put_read_data_locked(struct i3c_dev_desc *dev, struct i3c_priv_xfer *xfers,
+				 int nxfers, const u8 *ibi_data, int ibi_len);
 int i3c_dev_control_pec(struct i3c_dev_desc *dev, bool pec);
 #endif /* I3C_INTERNAL_H */
diff -Naur linux_org/drivers/i3c/Kconfig linux/drivers/i3c/Kconfig
--- linux_org/drivers/i3c/Kconfig	2024-02-06 01:18:16.459866416 +0800
+++ linux/drivers/i3c/Kconfig	2024-02-15 00:00:02.546932826 +0800
@@ -48,57 +48,6 @@
 	  I3C HUB drivers will be loaded automatically when I3C device with BCR
 	  equals to 0xC2 (HUB device) is detected on the bus.
 
-
-if I3CDEV
-config I3CDEV_FORCE_CREATE
-	bool "force create I3C device interface"
-	default n
-	help
-	  Say 'y' to force create I3C devices under /dev/bus/i3c/ regardless of
-	  driver binding.  This option is to help development so it shall be
-	  turned off in production.
-
-config I3CDEV_XFER_HDR_DDR
-	bool "transfer with HDR-DDR mode"
-	default y
-	help
-	  Say 'y' to use the HDR-DDR mode to transfer data if the device support it.
-	  This option is to help development so it shall be turned off in production.
-endif # I3CDEV
-
-config I3C_AST_BRIDGE_IC
-	bool "Aspeed Bridge IC driver"
-	default y
-	help
-	  Say y to enable Aspeed bridge IC device driver.
-
-config I3C_MUX_IMX3102
-	bool "IMX/IML3102 I3C multiplexer driver"
-	default y
-	select REGMAP_I3C
-	help
-	  Say y to enable Renesas IMX3102 I3C 2:1 multiplexer.
-
-choice
-	prompt "I3C secondary master / slave mode driver selection"
-	default I3C_SLAVE_MQUEUE
-
-config I3C_SLAVE_MQUEUE
-	bool "I3C mqueue (message queue) secondary master and slave driver"
-	help
-	  Some protocols over I3C are designed for bi-directional transferring
-	  messages by using I3C Master Write protocol. This driver is used to
-	  receive and queue messages from the remote I3C main master device.
-
-	  Userspace can get the messages by reading sysfs file that this driver
-	  exposes.
-
-config I3C_SLAVE_EEPROM
-	bool "I3C EEPROM secondary master and slave driver"
-	help
-	  This driver makes the slave mode I3C controller simulate the EEPROM.
-endchoice
-
 source "drivers/i3c/master/Kconfig"
 
 endif # I3C
diff -Naur linux_org/drivers/i3c/master/dw-i3c-master.c linux/drivers/i3c/master/dw-i3c-master.c
--- linux_org/drivers/i3c/master/dw-i3c-master.c	2024-02-06 01:18:16.243869582 +0800
+++ linux/drivers/i3c/master/dw-i3c-master.c	2024-02-15 00:00:02.546932826 +0800
@@ -6,33 +6,54 @@
  */
 
 #include <linux/bitops.h>
+#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/completion.h>
 #include <linux/err.h>
 #include <linux/errno.h>
 #include <linux/i3c/master.h>
+#include <linux/i3c/target.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
 #include <linux/iopoll.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/mfd/syscon.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/regmap.h>
 #include <linux/reset.h>
 #include <linux/slab.h>
 
+/*
+ * Below bits are valid for I3Cx Global register (REG1) on AST2600 platform.
+ * It is possible to issue dummy SCL or SDA toggling to the I3C controller without
+ * changing actual bus state.
+ * For successful toggling both _EN and _VAL bits must be 1 for the corresponding line.
+ */
+#define SDA_IN_SW_MODE_EN		BIT(29)
+#define SCL_IN_SW_MODE_EN		BIT(28)
+#define SDA_IN_SW_MODE_VAL		BIT(27)
+#define SCL_IN_SW_MODE_VAL		BIT(23)
+
 #define DEVICE_CTRL			0x0
 #define DEV_CTRL_ENABLE			BIT(31)
 #define DEV_CTRL_RESUME			BIT(30)
+#define DEV_CTRL_IBI_TRGT_MDB_MASK	GENMASK(23, 16)
+#define DEV_CTRL_IBI_TRGT_MDB(x)	((x) << 16)
+#define DEV_CTRL_IBI_PAYLOAD_EN		BIT(9)
 #define DEV_CTRL_HOT_JOIN_NACK		BIT(8)
 #define DEV_CTRL_I2C_SLAVE_PRESENT	BIT(7)
+#define DEV_CTRL_IBA_INCLUDE		BIT(0)
 
 #define DEVICE_ADDR			0x4
 #define DEV_ADDR_DYNAMIC_ADDR_VALID	BIT(31)
 #define DEV_ADDR_DYNAMIC(x)		(((x) << 16) & GENMASK(22, 16))
+#define DEV_ADDR_DYNAMIC_GET(x)		(((x) & GENMASK(22, 16)) >> 16)
 
 #define HW_CAPABILITY			0x8
 #define COMMAND_QUEUE_PORT		0xc
+#define COMMAND_PORT_PEC		BIT(31)
 #define COMMAND_PORT_TOC		BIT(30)
 #define COMMAND_PORT_READ_TRANSFER	BIT(28)
 #define COMMAND_PORT_SDAP		BIT(27)
@@ -47,6 +68,9 @@
 #define COMMAND_PORT_ARG_DATA_LEN_MAX	65536
 #define COMMAND_PORT_TRANSFER_ARG	0x01
 
+#define COMMAND_PORT_SLAVE_DATA_LEN	GENMASK(31, 16)
+#define COMMAND_PORT_SLAVE_TID(x)	(((x) << 3) & GENMASK(5, 3))
+
 #define COMMAND_PORT_SDA_DATA_BYTE_3(x)	(((x) << 24) & GENMASK(31, 24))
 #define COMMAND_PORT_SDA_DATA_BYTE_2(x)	(((x) << 16) & GENMASK(23, 16))
 #define COMMAND_PORT_SDA_DATA_BYTE_1(x)	(((x) << 8) & GENMASK(15, 8))
@@ -70,16 +94,41 @@
 #define RESPONSE_ERROR_TRANSF_ABORT	8
 #define RESPONSE_ERROR_I2C_W_NACK_ERR	9
 #define RESPONSE_PORT_TID(x)		(((x) & GENMASK(27, 24)) >> 24)
+#define TID_SLAVE_IBI			0x1
+#define TID_MASTER_READ			0x2
+#define TID_MASTER_WRITE		0x3
 #define RESPONSE_PORT_DATA_LEN(x)	((x) & GENMASK(15, 0))
 
+#define RESPONSE_PORT_SLAVE_TID(x)	(((x) & GENMASK(26, 24)) >> 24)
+
 #define RX_TX_DATA_PORT			0x14
 #define IBI_QUEUE_STATUS		0x18
+#define IBI_QUEUE_STATUS_RSP_NACK	BIT(31)
+#define IBI_QUEUE_STATUS_PEC_ERR	BIT(30)
+#define IBI_QUEUE_STATUS_LAST_FRAG	BIT(24)
+#define IBI_QUEUE_STATUS_IBI_ID(x)	(((x) & GENMASK(15, 8)) >> 8)
+#define IBI_QUEUE_STATUS_DATA_LEN(x)	((x) & GENMASK(7, 0))
+
+#define IBI_QUEUE_IBI_ADDR(x)		(IBI_QUEUE_STATUS_IBI_ID(x) >> 1)
+#define IBI_QUEUE_IBI_RNW(x)		(IBI_QUEUE_STATUS_IBI_ID(x) & BIT(0))
+#define IBI_TYPE_SIR(x)                                                         \
+	({ typeof(x) x_ = (x);							\
+	(IBI_QUEUE_IBI_ADDR(x_) != I3C_HOT_JOIN_ADDR) && IBI_QUEUE_IBI_RNW(x_); })
+
+#define IBI_QUEUE_DATA			0x18
+#define IBI_QUEUE_DATA_STATUS_MASK	GENMASK(31, 28)
+#define IBI_QUEUE_DATA_PAYLOAD_MASK	GENMASK(15, 8)
 #define QUEUE_THLD_CTRL			0x1c
+#define QUEUE_THLD_CTRL_IBI_STA_MASK	GENMASK(31, 24)
+#define QUEUE_THLD_CTRL_IBI_STA(x)	(((x) - 1) << 24)
+#define QUEUE_THLD_CTRL_IBI_DAT_MASK	GENMASK(23, 16)
+#define QUEUE_THLD_CTRL_IBI_DAT(x)	((x) << 16)
 #define QUEUE_THLD_CTRL_RESP_BUF_MASK	GENMASK(15, 8)
 #define QUEUE_THLD_CTRL_RESP_BUF(x)	(((x) - 1) << 8)
 
 #define DATA_BUFFER_THLD_CTRL		0x20
-#define DATA_BUFFER_THLD_CTRL_RX_BUF	GENMASK(11, 8)
+#define DATA_BUFFER_THLD_TX_START	GENMASK(18, 16)
+#define DATA_BUFFER_THLD_CTRL_RX_BUF	GENMASK(10, 8)
 
 #define IBI_QUEUE_CTRL			0x24
 #define IBI_MR_REQ_REJECT		0x2C
@@ -93,8 +142,18 @@
 #define RESET_CTRL_RESP_QUEUE		BIT(2)
 #define RESET_CTRL_CMD_QUEUE		BIT(1)
 #define RESET_CTRL_SOFT			BIT(0)
+#define RESET_CTRL_QUEUES		(RESET_CTRL_IBI_QUEUE |	\
+					 RESET_CTRL_RX_FIFO |	\
+					 RESET_CTRL_TX_FIFO |	\
+					 RESET_CTRL_RESP_QUEUE |\
+					 RESET_CTRL_CMD_QUEUE)
 
 #define SLV_EVENT_CTRL			0x38
+#define SLV_EVENT_CTRL_SIR_EN		BIT(0)
+#define SLV_EVENT_CTRL_HJ_EN		BIT(3)
+#define SLV_EVENT_CTRL_MRL_UPD		BIT(6)
+#define SLV_EVENT_CTRL_MWL_UPD		BIT(7)
+
 #define INTR_STATUS			0x3c
 #define INTR_STATUS_EN			0x40
 #define INTR_SIGNAL_EN			0x44
@@ -125,10 +184,16 @@
 					INTR_IBI_THLD_STAT |		\
 					INTR_TX_THLD_STAT |		\
 					INTR_RX_THLD_STAT)
-
 #define INTR_MASTER_MASK		(INTR_TRANSFER_ERR_STAT |	\
 					 INTR_RESP_READY_STAT)
 
+#define INTR_TARGET_MASK		(INTR_READ_REQ_RECV_STAT |	\
+					INTR_RESP_READY_STAT |		\
+					INTR_IBI_UPDATED_STAT  |	\
+					INTR_TRANSFER_ERR_STAT |	\
+					INTR_DYN_ADDR_ASSGN_STAT |	\
+					INTR_CCC_UPDATED_STAT)
+
 #define QUEUE_STATUS_LEVEL		0x4c
 #define QUEUE_STATUS_IBI_STATUS_CNT(x)	(((x) & GENMASK(28, 24)) >> 24)
 #define QUEUE_STATUS_IBI_BUF_BLR(x)	(((x) & GENMASK(23, 16)) >> 16)
@@ -139,21 +204,46 @@
 #define DATA_BUFFER_STATUS_LEVEL_TX(x)	((x) & GENMASK(7, 0))
 
 #define PRESENT_STATE			0x54
+#define PRESENT_STATE_CM_TFR_STS(x)	(((x) & GENMASK(13, 8)) >> 8)
+#define CM_TFR_STS_SLAVE_HALT		0x6
+#define CM_TFR_STS_MASTER_SERV_IBI	0xe
 #define CCC_DEVICE_STATUS		0x58
 #define DEVICE_ADDR_TABLE_POINTER	0x5c
 #define DEVICE_ADDR_TABLE_DEPTH(x)	(((x) & GENMASK(31, 16)) >> 16)
-#define DEVICE_ADDR_TABLE_ADDR(x)	((x) & GENMASK(7, 0))
+#define DEVICE_ADDR_TABLE_ADDR(x)	((x) & GENMASK(15, 0))
 
 #define DEV_CHAR_TABLE_POINTER		0x60
 #define VENDOR_SPECIFIC_REG_POINTER	0x6c
+#define SLV_MIPI_ID_VALUE		0x70
 #define SLV_PID_VALUE			0x74
+#define SLV_PID_HI(x)			(((x) >> 32) & GENMASK(15, 0))
+#define SLV_PID_LO(x)			((x) & GENMASK(31, 0))
 #define SLV_CHAR_CTRL			0x78
+#define SLV_DCR_MASK			GENMASK(15, 8)
+#define SLV_DCR(x)			(((x) << 8) & SLV_DCR_MASK)
+#define SLV_DEVICE_ROLE_MASK		GENMASK(7, 6)
+#define SLV_DEVICE_ROLE(x)		(((x) << 6) & SLV_DEVICE_ROLE_MASK)
+#define SLV_HDR_CAPABLE			BIT(5)
+#define SLV_MAX_DATA_SPEED_LIMIT	BIT(0)
+
 #define SLV_MAX_LEN			0x7c
+#define SLV_MAX_RD_LEN(x)		(((x) & GENMASK(31, 16)) >> 16)
+#define SLV_MAX_WR_LEN(x)		((x) & GENMASK(15, 0))
+
 #define MAX_READ_TURNAROUND		0x80
 #define MAX_DATA_SPEED			0x84
 #define SLV_DEBUG_STATUS		0x88
 #define SLV_INTR_REQ			0x8c
+#define SLV_INTR_REQ_IBI_STS(x)		(((x) & GENMASK(9, 8)) >> 8)
+#define IBI_STS_ACCEPTED		0x01
+#define IBI_STS_NOT_ATTEMPTED		0x11
+
 #define DEVICE_CTRL_EXTENDED		0xb0
+#define DEVICE_CTRL_EXTENDED_MODE_MASK	GENMASK(1, 0)
+#define DEVICE_CTRL_EXTENDED_MODE(x)	((x) & DEVICE_CTRL_EXTENDED_MODE_MASK)
+#define DEV_OPERATION_MODE_CONTROLLER	0x00
+#define DEV_OPERATION_MODE_TARGET	0x01
+
 #define SCL_I3C_OD_TIMING		0xb4
 #define SCL_I3C_PP_TIMING		0xb8
 #define SCL_I3C_TIMING_HCNT(x)		(((x) << 16) & GENMASK(23, 16))
@@ -175,17 +265,40 @@
 #define SCL_EXT_LCNT_1(x)		((x) & GENMASK(7, 0))
 
 #define SCL_EXT_TERMN_LCNT_TIMING	0xcc
+
+#define SDA_HOLD_SWITCH_DLY_TIMING	0xd0
+#define SDA_TX_HOLD(x)			(((x) << 16) & GENMASK(18, 16))
+#define SDA_TX_HOLD_MIN			1
+#define SDA_TX_HOLD_MAX			7
+
 #define BUS_FREE_TIMING			0xd4
+#define BUS_AVAIL_TIME(x)		(((x) << 16) & GENMASK(31, 16))
+#define BUS_AVAIL_TIME_GET(x)		(((x) & GENMASK(31, 16)) >> 16)
+#define MAX_BUS_AVAIL_CNT		0xffffU
 #define BUS_I3C_MST_FREE(x)		((x) & GENMASK(15, 0))
 
 #define BUS_IDLE_TIMING			0xd8
 #define I3C_VER_ID			0xe0
 #define I3C_VER_TYPE			0xe4
+#define I3C_VER_RELEASE_TYPE(x)		(((x) & GENMASK(31, 16)) >> 16)
+#define I3C_VER_RELEASE_VERSION(x)	((x) & GENMASK(15, 0))
+
+#define I3C_LC_RELEASE			0x6c63
+
 #define EXTENDED_CAPABILITY		0xe8
 #define SLAVE_CONFIG			0xec
 
 #define DEV_ADDR_TABLE_LEGACY_I2C_DEV	BIT(31)
-#define DEV_ADDR_TABLE_DYNAMIC_ADDR(x)	(((x) << 16) & GENMASK(23, 16))
+#define DEV_ADDR_TABLE_DEV_NACK_RETRY(x) (((x) << 29) & GENMASK(30, 29))
+#define DEV_ADDR_TABLE_MR_REJECT	BIT(14)
+#define DEV_ADDR_TABLE_SIR_REJECT	BIT(13)
+#define DEV_ADDR_TABLE_IBI_WITH_DATA	BIT(12)
+#define DEV_ADDR_TABLE_IBI_PEC_EN	BIT(11)
+#define DEV_ADDR_TABLE_DYNAMIC_ADDR_PARITY_MASK	BIT(23)
+#define DEV_ADDR_TABLE_DYNAMIC_ADDR_PARITY(x)	(((x) << 23) & BIT(23))
+#define DEV_ADDR_TABLE_DYNAMIC_ADDR_MASK	GENMASK(22, 16)
+#define DEV_ADDR_TABLE_DYNAMIC_ADDR(x)	(((x) << 16) & DEV_ADDR_TABLE_DYNAMIC_ADDR_MASK)
+#define DEV_ADDR_TABLE_DYNAMIC_ADDR_GET(x)	(((x) & DEV_ADDR_TABLE_DYNAMIC_ADDR_MASK) >> 16)
 #define DEV_ADDR_TABLE_STATIC_ADDR(x)	((x) & GENMASK(6, 0))
 #define DEV_ADDR_TABLE_LOC(start, idx)	((start) + ((idx) << 2))
 
@@ -196,10 +309,51 @@
 #define I3C_BUS_SDR3_SCL_RATE		4000000
 #define I3C_BUS_SDR4_SCL_RATE		2000000
 #define I3C_BUS_I2C_FM_TLOW_MIN_NS	1300
+#define I3C_BUS_I2C_FM_THIGH_MIN_NS	600
 #define I3C_BUS_I2C_FMP_TLOW_MIN_NS	500
-#define I3C_BUS_THIGH_MAX_NS		41
+#define I3C_BUS_I2C_FMP_THIGH_MIN_NS	260
+#define I3C_BUS_I3C_OD_TLOW_MIN_NS	200
+#define I3C_BUS_I3C_OD_THIGH_MAX_NS	41
+#define I3C_BUS_I3C_PP_TLOW_MIN_NS	25
+#define I3C_BUS_I3C_PP_THIGH_MIN_NS	25
+
+#define I3C_MCTP_MDB			0xAE
 
 #define XFER_TIMEOUT (msecs_to_jiffies(1000))
+#define TARGET_MASTER_READ_TIMEOUT	(msecs_to_jiffies(100))
+
+/* AST2600-specific global register set */
+#define AST2600_I3CG_REG0(idx)	(((idx) * 4 * 4) + 0x10)
+#define AST2600_I3CG_REG1(idx)	(((idx) * 4 * 4) + 0x14)
+
+#define AST2600_I3CG_REG0_SDA_PULLUP_EN_MASK	GENMASK(29, 28)
+#define AST2600_I3CG_REG0_SDA_PULLUP_EN_2K	(0x0 << 28)
+#define AST2600_I3CG_REG0_SDA_PULLUP_EN_750	(0x2 << 28)
+
+#define AST2600_I3CG_REG1_I2C_MODE		BIT(0)
+#define AST2600_I3CG_REG1_TEST_MODE		BIT(1)
+#define AST2600_I3CG_REG1_ACT_MODE_MASK		GENMASK(3, 2)
+#define AST2600_I3CG_REG1_ACT_MODE(x)		(((x) << 2) & AST2600_I3CG_REG1_ACT_MODE_MASK)
+#define AST2600_I3CG_REG1_PENDING_INT_MASK	GENMASK(7, 4)
+#define AST2600_I3CG_REG1_PENDING_INT(x)	(((x) << 4) & AST2600_I3CG_REG1_PENDING_INT_MASK)
+#define AST2600_I3CG_REG1_SA_MASK		GENMASK(14, 8)
+#define AST2600_I3CG_REG1_SA(x)			(((x) << 8) & AST2600_I3CG_REG1_SA_MASK)
+#define AST2600_I3CG_REG1_SA_EN			BIT(15)
+#define AST2600_I3CG_REG1_INST_ID_MASK		GENMASK(19, 16)
+#define AST2600_I3CG_REG1_INST_ID(x)		(((x) << 16) & AST2600_I3CG_REG1_INST_ID_MASK)
+
+#define AST2600_DEFAULT_SDA_PULLUP_OHMS		2000
+
+#define DW_I3C_TIMING_MIN 0x0
+#define DW_I3C_TIMING_MAX 0xffffffff
+
+#define AST2600_I3C_IBI_MAX_PAYLOAD	255
+
+/*
+ * HW DAT slot used in SW DAT mechanism for communication with all I3C target
+ * devies for which IBI is not enabled.
+ */
+#define DEVICE_ADDR_TABLE_COMMON_SLOT	0
 
 struct dw_i3c_master_caps {
 	u8 cmdfifodepth;
@@ -224,9 +378,17 @@
 	struct dw_i3c_cmd cmds[];
 };
 
+struct pdata_ast2600 {
+	struct regmap *global_regs;
+	unsigned int global_idx;
+	unsigned int sda_pullup;
+};
+
 struct dw_i3c_master {
+	struct device *dev;
 	struct i3c_master_controller base;
 	u16 maxdevs;
+	u16 dat_depth;
 	u16 datstartaddr;
 	u32 free_pos;
 	struct {
@@ -234,17 +396,91 @@
 		struct dw_i3c_xfer *cur;
 		spinlock_t lock;
 	} xferqueue;
+	union {
+		struct {
+			struct i3c_dev_desc *slots[MAX_DEVS];
+			u32 received_ibi_len[MAX_DEVS];
+			/*
+			 * Prevents simultaneous access to IBI related registers
+			 * and slots array.
+			 */
+			spinlock_t lock;
+		} master;
+		struct {
+			struct completion comp;
+		} target;
+	} ibi;
+	struct completion target_read_comp;
+	u32 target_read_timeout;
 	struct dw_i3c_master_caps caps;
 	void __iomem *regs;
 	struct reset_control *core_rst;
 	struct clk *core_clk;
-	char version[5];
-	char type[5];
+	u32 ver_id;
+	u16 ver_type;
 	u8 addrs[MAX_DEVS];
+
+	/* platform-specific data */
+	const struct dw_i3c_platform_ops *platform_ops;
+	union {
+		struct pdata_ast2600 ast2600;
+	} pdata;
+
+	/* All parameters are expressed in nanoseconds */
+	struct {
+		unsigned long i3c_core_rate;
+		unsigned long i3c_core_period;
+		u32 i3c_od_scl_freq;
+		u32 i3c_od_scl_low;
+		u32 i3c_od_scl_high;
+		u32 i3c_pp_scl_freq;
+		u32 i3c_pp_scl_low;
+		u32 i3c_pp_scl_high;
+		u32 sda_tx_hold;
+	} timings;
+	/* Used for handling private write */
+	struct {
+		void *buf;
+		u16 max_len;
+	} target_rx;
+
+	bool sw_dat_enabled;
+	struct {
+		u32 dat;
+		bool hw_dat_linked;
+		int hw_dat_index;
+	} sw_dat[MAX_DEVS];
+};
+
+struct dw_i3c_platform_ops {
+	int (*probe)(struct dw_i3c_master *i3c, struct platform_device *pdev);
+	int (*init)(struct dw_i3c_master *i3c);
+	void (*toggle_scl_in)(struct dw_i3c_master *master, u8 times);
+	void (*isolate_scl_sda)(struct dw_i3c_master *master, bool iso);
+	void (*gen_stop_to_internal)(struct dw_i3c_master *master);
+	void (*gen_tbits_in)(struct dw_i3c_master *master);
 };
 
 struct dw_i3c_i2c_dev_data {
 	u8 index;
+	s8 ibi;
+	struct i3c_generic_ibi_pool *ibi_pool;
+};
+
+/*
+ * All timing parameters are expressed in nanoseconds.
+ * All frequency parameters are expressed in Hz
+ */
+struct dw_i3c_scl_timing {
+	u32 high;
+	u32 high_min;
+	u32 high_max;
+	u32 low;
+	u32 low_min;
+	u32 low_max;
+	u32 freq;
+	u32 freq_min;
+	u32 freq_max;
 };
 
 static u8 even_parity(u8 p)
@@ -286,6 +522,8 @@
 	case I3C_CCC_GETSTATUS:
 	case I3C_CCC_GETMXDS:
 	case I3C_CCC_GETHDRCAP:
+	case I3C_CCC_SETAASA:
+	case I3C_CCC_SETHID:
 		return true;
 	default:
 		return false;
@@ -295,7 +533,79 @@
 static inline struct dw_i3c_master *
 to_dw_i3c_master(struct i3c_master_controller *master)
 {
-	return container_of(master, struct dw_i3c_master, base);
+	return (struct dw_i3c_master *)master->bus_driver_context;
+}
+
+static bool dw_i3c_master_fsm_is_idle(struct dw_i3c_master *master)
+{
+	/*
+	 * Clear the IBI queue to enable the hardware to generate SCL and
+	 * begin detecting the T-bit low to stop reading IBI data.
+	 */
+	readl(master->regs + IBI_QUEUE_DATA);
+
+	return !PRESENT_STATE_CM_TFR_STS(readl(master->regs + PRESENT_STATE));
+}
+
+static void ast2600_i3c_toggle_scl_in(struct dw_i3c_master *master, u8 times)
+{
+	struct pdata_ast2600 *pdata = &master->pdata.ast2600;
+
+	for (; times; times--) {
+		regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+				  SCL_IN_SW_MODE_VAL, 0);
+		regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+				  SCL_IN_SW_MODE_VAL, SCL_IN_SW_MODE_VAL);
+	}
+}
+
+static void ast2600_i3c_isolate_scl_sda(struct dw_i3c_master *master, bool iso)
+{
+	struct pdata_ast2600 *pdata = &master->pdata.ast2600;
+
+	if (iso) {
+		regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+				  SCL_IN_SW_MODE_VAL | SDA_IN_SW_MODE_VAL,
+				  SCL_IN_SW_MODE_VAL | SDA_IN_SW_MODE_VAL);
+		regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+				  SCL_IN_SW_MODE_EN | SDA_IN_SW_MODE_EN,
+				  SCL_IN_SW_MODE_EN | SDA_IN_SW_MODE_EN);
+	} else {
+		regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+				  SCL_IN_SW_MODE_EN | SDA_IN_SW_MODE_EN, 0);
+	}
+}
+
+static void ast2600_i3c_gen_stop_to_internal(struct dw_i3c_master *master)
+{
+	struct pdata_ast2600 *pdata = &master->pdata.ast2600;
+
+	regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+			  SCL_IN_SW_MODE_VAL, SCL_IN_SW_MODE_VAL);
+	regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+			  SDA_IN_SW_MODE_VAL, 0);
+	regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+			  SDA_IN_SW_MODE_VAL, SDA_IN_SW_MODE_VAL);
+}
+
+static void ast2600_i3c_gen_tbits_in(struct dw_i3c_master *master)
+{
+	struct pdata_ast2600 *pdata = &master->pdata.ast2600;
+	bool is_idle;
+
+	regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+			  SDA_IN_SW_MODE_VAL, SDA_IN_SW_MODE_VAL);
+	regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+			  SDA_IN_SW_MODE_EN, SDA_IN_SW_MODE_EN);
+	regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+			  SDA_IN_SW_MODE_VAL, 0);
+	if (readx_poll_timeout_atomic(dw_i3c_master_fsm_is_idle, master, is_idle,
+				      is_idle, 0, 2000000))
+		dev_err(master->dev,
+			"Failed to recover the i3c fsm from %lx to idle",
+			PRESENT_STATE_CM_TFR_STS(readl(master->regs + PRESENT_STATE)));
+	regmap_write_bits(pdata->global_regs, AST2600_I3CG_REG1(pdata->global_idx),
+			  SDA_IN_SW_MODE_EN, 0);
 }
 
 static void dw_i3c_master_disable(struct dw_i3c_master *master)
@@ -310,6 +620,19 @@
 	       master->regs + DEVICE_CTRL);
 }
 
+static void dw_i3c_master_resume(struct dw_i3c_master *master)
+{
+	writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_RESUME,
+	       master->regs + DEVICE_CTRL);
+}
+
+static int dw_i3c_master_poll_enable_bit(struct dw_i3c_master *master)
+{
+	if (master->platform_ops && master->platform_ops->toggle_scl_in)
+		master->platform_ops->toggle_scl_in(master, 8);
+	return readl(master->regs + DEVICE_CTRL) & DEV_CTRL_ENABLE;
+}
+
 static int dw_i3c_master_get_addr_pos(struct dw_i3c_master *master, u8 addr)
 {
 	int pos;
@@ -330,6 +653,227 @@
 	return ffs(master->free_pos) - 1;
 }
 
+static int dw_i3c_master_remove_dev(struct dw_i3c_master *master, u8 pos)
+{
+	if (pos > master->maxdevs)
+		return -EINVAL;
+
+	master->free_pos |= BIT(pos);
+	master->addrs[pos] = 0;
+	if (master->sw_dat_enabled) {
+		master->sw_dat[pos].dat = 0;
+		if (master->sw_dat[pos].hw_dat_linked)
+			writel(0, master->regs +
+			       DEV_ADDR_TABLE_LOC(master->datstartaddr,
+						  master->sw_dat[pos].hw_dat_index));
+		master->sw_dat[pos].hw_dat_linked = false;
+	} else {
+		writel(0, master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));
+	}
+
+	return 0;
+}
+
+static int dw_i3c_master_add_i3c_dev(struct dw_i3c_master *master, u8 addr, u8 pos)
+{
+	u32 dat_reg;
+
+	if (pos > master->maxdevs)
+		return -EINVAL;
+
+	master->free_pos &= ~BIT(pos);
+	master->addrs[pos] = addr;
+	dat_reg = DEV_ADDR_TABLE_DYNAMIC_ADDR_PARITY(even_parity(addr)) |
+		  DEV_ADDR_TABLE_DYNAMIC_ADDR(addr);
+	if (master->sw_dat_enabled) {
+		master->sw_dat[pos].dat = dat_reg;
+		master->sw_dat[pos].hw_dat_linked = false;
+	} else {
+		writel(dat_reg, master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));
+	}
+
+	return 0;
+}
+
+static int dw_i3c_master_update_i3c_dev(struct dw_i3c_master *master, u8 addr, u8 pos)
+{
+	u32 dat_reg;
+
+	if (pos > master->maxdevs)
+		return -EINVAL;
+
+	if (master->sw_dat_enabled)
+		dat_reg = master->sw_dat[pos].dat;
+	else
+		dat_reg = readl(master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));
+
+	if (DEV_ADDR_TABLE_DYNAMIC_ADDR_GET(dat_reg) != addr) {
+		master->addrs[pos] = addr;
+		dat_reg &= ~(DEV_ADDR_TABLE_DYNAMIC_ADDR_PARITY_MASK |
+			     DEV_ADDR_TABLE_DYNAMIC_ADDR_MASK);
+		dat_reg |= DEV_ADDR_TABLE_DYNAMIC_ADDR_PARITY(even_parity(addr)) |
+			   DEV_ADDR_TABLE_DYNAMIC_ADDR(addr);
+		if (master->sw_dat_enabled) {
+			master->sw_dat[pos].dat = dat_reg;
+			if (master->sw_dat[pos].hw_dat_linked)
+				writel(dat_reg, master->regs +
+				       DEV_ADDR_TABLE_LOC(master->datstartaddr,
+							  master->sw_dat[pos].hw_dat_index));
+		} else {
+			writel(dat_reg, master->regs +
+			       DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));
+		}
+	}
+
+	return 0;
+}
+
+static int dw_i3c_master_add_i2c_dev(struct dw_i3c_master *master, u8 addr, u8 pos)
+{
+	if (pos > master->maxdevs)
+		return -EINVAL;
+
+	master->addrs[pos] = addr;
+	master->free_pos &= ~BIT(pos);
+	if (master->sw_dat_enabled) {
+		master->sw_dat[pos].dat = DEV_ADDR_TABLE_LEGACY_I2C_DEV |
+					  DEV_ADDR_TABLE_STATIC_ADDR(addr);
+		master->sw_dat[pos].hw_dat_linked = false;
+	} else {
+		writel(DEV_ADDR_TABLE_LEGACY_I2C_DEV | DEV_ADDR_TABLE_STATIC_ADDR(addr),
+		       master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));
+	}
+
+	return 0;
+}
+
+static void dw_i3c_master_link_hw_dat(struct dw_i3c_master *master, int index, int hw_dat_index)
+{
+	master->sw_dat[index].hw_dat_index = hw_dat_index;
+	master->sw_dat[index].hw_dat_linked = true;
+	writel(master->sw_dat[index].dat, master->regs +
+	       DEV_ADDR_TABLE_LOC(master->datstartaddr, hw_dat_index));
+}
+
+static void dw_i3c_master_unlink_hw_dat(struct dw_i3c_master *master, int hw_dat_index)
+{
+	u32 dat_reg;
+	int index;
+
+	dat_reg = readl(master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, hw_dat_index));
+	if (dat_reg != 0) {
+		writel(0, master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, hw_dat_index));
+		index = dw_i3c_master_get_addr_pos(master,
+						   DEV_ADDR_TABLE_DYNAMIC_ADDR_GET(dat_reg));
+		if (index >= 0)
+			master->sw_dat[index].hw_dat_linked = false;
+	}
+}
+
+static void dw_i3c_master_unlink_index(struct dw_i3c_master *master, int index)
+{
+	if (master->sw_dat[index].hw_dat_linked) {
+		writel(0, master->regs +
+		       DEV_ADDR_TABLE_LOC(master->datstartaddr,
+					  master->sw_dat[index].hw_dat_index));
+		master->sw_dat[index].hw_dat_linked = false;
+	}
+}
+
+static int dw_i3c_master_find_hw_dat_index_for_ibi(struct dw_i3c_master *master)
+{
+	int hw_dat_index;
+	u32 dat_reg;
+
+	for (hw_dat_index = DEVICE_ADDR_TABLE_COMMON_SLOT + 1; hw_dat_index < master->dat_depth;
+	     ++hw_dat_index) {
+		dat_reg = readl(master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr,
+								  hw_dat_index));
+		if (dat_reg == 0)
+			return hw_dat_index;
+	}
+
+	return -ENOSPC;
+}
+
+static int dw_i3c_master_enable_ibi_in_dat(struct dw_i3c_master *master, u8 index, bool ibi_payload)
+{
+	int dat_loc = DEV_ADDR_TABLE_LOC(master->datstartaddr, index);
+	u32 dat_reg;
+
+	if (master->sw_dat_enabled)
+		dat_reg = master->sw_dat[index].dat;
+	else
+		dat_reg = readl(master->regs + dat_loc);
+
+	dat_reg &= ~DEV_ADDR_TABLE_SIR_REJECT;
+	if (ibi_payload)
+		dat_reg |= DEV_ADDR_TABLE_IBI_WITH_DATA;
+	dat_reg |= DEV_ADDR_TABLE_IBI_PEC_EN;
+
+	if (master->sw_dat_enabled) {
+		int hw_dat_index;
+
+		/* If index already linked - unlink it */
+		dw_i3c_master_unlink_index(master, index);
+
+		/* Find HW DAT slot for IBI index */
+		hw_dat_index = dw_i3c_master_find_hw_dat_index_for_ibi(master);
+		if (hw_dat_index < 0)
+			return hw_dat_index;
+
+		/* Update DAT and link index to HW DAT */
+		master->sw_dat[index].dat = dat_reg;
+		dw_i3c_master_link_hw_dat(master, index, hw_dat_index);
+	} else {
+		writel(dat_reg, master->regs + dat_loc);
+	}
+
+	return 0;
+}
+
+static void dw_i3c_master_disable_ibi_in_dat(struct dw_i3c_master *master, u8 index)
+{
+	int dat_loc = DEV_ADDR_TABLE_LOC(master->datstartaddr, index);
+	u32 dat_reg;
+
+	if (master->sw_dat_enabled)
+		dat_reg = master->sw_dat[index].dat;
+	else
+		dat_reg = readl(master->regs + dat_loc);
+
+	dat_reg |= DEV_ADDR_TABLE_SIR_REJECT;
+	dat_reg &= ~DEV_ADDR_TABLE_IBI_WITH_DATA;
+	dat_reg &= ~DEV_ADDR_TABLE_IBI_PEC_EN;
+
+	if (master->sw_dat_enabled) {
+		dw_i3c_master_unlink_index(master, index);
+		master->sw_dat[index].dat = dat_reg;
+	} else {
+		writel(dat_reg, master->regs + dat_loc);
+	}
+}
+
+static int dw_i3c_master_alloc_and_get_hw_dat_index(struct dw_i3c_master *master, int index)
+{
+	if (!master->sw_dat_enabled)
+		return index;
+
+	/* If HW DAT already link use it */
+	if (master->sw_dat[index].hw_dat_linked)
+		return master->sw_dat[index].hw_dat_index;
+
+	/* If there is no HW DAT link for provided index use HW DAT common slot */
+
+	/* Unlink if there was any link for HW DAT common slot */
+	dw_i3c_master_unlink_hw_dat(master, DEVICE_ADDR_TABLE_COMMON_SLOT);
+
+	/* Link index to HW DAT common slot */
+	dw_i3c_master_link_hw_dat(master, index, DEVICE_ADDR_TABLE_COMMON_SLOT);
+
+	return DEVICE_ADDR_TABLE_COMMON_SLOT;
+}
+
 static void dw_i3c_master_wr_tx_fifo(struct dw_i3c_master *master,
 				     const u8 *bytes, int nbytes)
 {
@@ -339,21 +883,43 @@
 
 		memcpy(&tmp, bytes + (nbytes & ~3), nbytes & 3);
 		writesl(master->regs + RX_TX_DATA_PORT, &tmp, 1);
+		dev_dbg(master->dev, "TX data = %08x\n", tmp);
 	}
 }
 
-static void dw_i3c_master_read_rx_fifo(struct dw_i3c_master *master,
-				       u8 *bytes, int nbytes)
+static void dw_i3c_master_read_fifo(struct dw_i3c_master *master, u32 fifo_reg,
+				    u8 *bytes, int nbytes)
 {
-	readsl(master->regs + RX_TX_DATA_PORT, bytes, nbytes / 4);
+	readsl(master->regs + fifo_reg, bytes, nbytes / 4);
 	if (nbytes & 3) {
 		u32 tmp;
 
-		readsl(master->regs + RX_TX_DATA_PORT, &tmp, 1);
+		readsl(master->regs + fifo_reg, &tmp, 1);
 		memcpy(bytes + (nbytes & ~3), &tmp, nbytes & 3);
 	}
 }
 
+static void dw_i3c_master_read_rx_fifo(struct dw_i3c_master *master,
+				       u8 *bytes, int nbytes)
+{
+	dw_i3c_master_read_fifo(master, RX_TX_DATA_PORT, bytes, nbytes);
+}
+
+static void dw_i3c_master_read_ibi_fifo(struct dw_i3c_master *master,
+					u8 *bytes, int nbytes)
+{
+	dw_i3c_master_read_fifo(master, IBI_QUEUE_DATA, bytes, nbytes);
+}
+
+static void dw_i3c_master_flush_ibi_fifo(struct dw_i3c_master *master, int nbytes)
+{
+	int nwords = (nbytes + 3) >> 2;
+	int i;
+
+	for (i = 0; i < nwords; i++)
+		readl(master->regs + IBI_QUEUE_DATA);
+}
+
 static struct dw_i3c_xfer *
 dw_i3c_master_alloc_xfer(struct dw_i3c_master *master, unsigned int ncmds)
 {
@@ -466,7 +1032,7 @@
 
 		resp = readl(master->regs + RESPONSE_QUEUE_PORT);
 
-		cmd = &xfer->cmds[RESPONSE_PORT_TID(resp)];
+		cmd = &xfer->cmds[i];
 		cmd->rx_len = RESPONSE_PORT_DATA_LEN(resp);
 		cmd->error = RESPONSE_PORT_ERR_STATUS(resp);
 		if (cmd->rx_len && !cmd->error)
@@ -515,11 +1081,224 @@
 	dw_i3c_master_start_xfer_locked(master);
 }
 
+static void _timing_calc_when_no_params(struct dw_i3c_scl_timing *timings, u32 *scl_high,
+					u32 *scl_low, u32 *scl_period_ns)
+{
+	u32 high, low, period;
+
+	period = DIV_ROUND_CLOSEST(1000000000, timings->freq_max);
+	high = clamp(period / 2, timings->high_min, timings->high_max);
+	low = timings->low_min;
+
+	if (period > high) {
+		u32 delta = period - high;
+
+		if (delta > timings->low_max)
+			low = timings->low_max;
+		else if (delta >= timings->low_min)
+			low = delta;
+	}
+
+	*scl_high = high;
+	*scl_low = low;
+	*scl_period_ns = high + low;
+}
+
+static int _timing_calc_when_scl_high(struct dw_i3c_scl_timing *timings, u32 *scl_high,
+				      u32 *scl_low, u32 *scl_period_ns)
+{
+	u32 high, low, period;
+
+	high = timings->high;
+	low = timings->low_min;
+	period = DIV_ROUND_CLOSEST(1000000000, timings->freq_max);
+
+	if (period > high) {
+		u32 delta = period - high;
+
+		if (delta > timings->low_max)
+			low = timings->low_max;
+		else if (delta >= timings->low_min)
+			low = delta;
+	}
+
+	*scl_high = high;
+	*scl_low = low;
+	*scl_period_ns = high + low;
+
+	return 0;
+}
+
+static int _timing_calc_when_scl_low(struct dw_i3c_scl_timing *timings, u32 *scl_high,
+				     u32 *scl_low, u32 *scl_period_ns)
+{
+	u32 high, low, period;
+
+	low = timings->low;
+	high = timings->high_min;
+	period = DIV_ROUND_CLOSEST(1000000000, timings->freq_max);
+
+	if (period > low) {
+		u32 delta = period - low;
+
+		if (delta > timings->high_max)
+			high = timings->high_max;
+		else if (delta >= timings->high_min)
+			high = delta;
+	}
+
+	*scl_high = high;
+	*scl_low = low;
+	*scl_period_ns = high + low;
+
+	return 0;
+}
+
+static int _timing_calc_when_scl_freq(struct dw_i3c_scl_timing *timings, u32 *scl_high,
+				      u32 *scl_low, u32 *scl_period_ns)
+{
+	u32 high, period;
+
+	period = DIV_ROUND_CLOSEST(1000000000, timings->freq);
+	high = clamp(period / 2, timings->high_min, timings->high_max);
+	if (period <= high)
+		return -EINVAL;
+
+	*scl_high = high;
+	*scl_low = period - high;
+	*scl_period_ns = period;
+
+	return 0;
+}
+
+static int _timing_calc_when_scl_high_low(struct dw_i3c_scl_timing *timings, u32 *scl_high,
+					  u32 *scl_low, u32 *scl_period_ns)
+{
+	*scl_high = timings->high;
+	*scl_low = timings->low;
+	*scl_period_ns = *scl_high + *scl_low;
+
+	return 0;
+}
+
+static int _timing_calc_when_scl_high_freq(struct dw_i3c_scl_timing *timings, u32 *scl_high,
+					   u32 *scl_low, u32 *scl_period_ns)
+{
+	*scl_period_ns = DIV_ROUND_CLOSEST(1000000000, timings->freq);
+	*scl_high = timings->high;
+	if (*scl_period_ns <= *scl_high)
+		return -EINVAL;
+
+	*scl_low = *scl_period_ns - *scl_high;
+
+	return 0;
+}
+
+static int _timing_calc_when_scl_low_freq(struct dw_i3c_scl_timing *timings, u32 *scl_high,
+					  u32 *scl_low, u32 *scl_period_ns)
+{
+	*scl_period_ns = DIV_ROUND_CLOSEST(1000000000, timings->freq);
+	*scl_low = timings->low;
+	if (*scl_period_ns <= *scl_low)
+		return -EINVAL;
+
+	*scl_high = *scl_period_ns - *scl_low;
+
+	return 0;
+}
+
+static int _timing_calc_when_all(struct dw_i3c_scl_timing *timings, u32 *scl_high,
+				 u32 *scl_low, u32 *scl_period_ns)
+{
+	*scl_period_ns = DIV_ROUND_CLOSEST(1000000000, timings->freq);
+	*scl_high = timings->high;
+	*scl_low = timings->low;
+
+	return 0;
+}
+
+static int dw_i3c_timing_calc(struct dw_i3c_scl_timing *timings, u32 *scl_high, u32 *scl_low)
+{
+	u32 high = timings->high;
+	u32 low = timings->low;
+	u32 freq = timings->freq;
+	u32 period;
+	int ret = 0;
+
+	if ((high > 0 && (high < timings->high_min || high > timings->high_max)) ||
+	    (low > 0 && (low < timings->low_min || low > timings->low_max)) ||
+	    (freq > 0 && (freq < timings->freq_min || freq > timings->freq_max)))
+		return -EINVAL;
+
+	if (high == 0 && low == 0 && freq == 0)
+		_timing_calc_when_no_params(timings, &high, &low, &period);
+	else if (high > 0 && low == 0 && freq == 0)
+		ret = _timing_calc_when_scl_high(timings, &high, &low, &period);
+	else if (high == 0 && low > 0 && freq == 0)
+		ret = _timing_calc_when_scl_low(timings, &high, &low, &period);
+	else if (high == 0 && low == 0 && freq > 0)
+		ret = _timing_calc_when_scl_freq(timings, &high, &low, &period);
+	else if (high > 0 && low > 0 && freq == 0)
+		ret = _timing_calc_when_scl_high_low(timings, &high, &low, &period);
+	else if (high > 0 && low == 0 && freq > 0)
+		ret = _timing_calc_when_scl_high_freq(timings, &high, &low, &period);
+	else if (high == 0 && low > 0 && freq > 0)
+		ret = _timing_calc_when_scl_low_freq(timings, &high, &low, &period);
+	else
+		ret = _timing_calc_when_all(timings, &high, &low, &period);
+
+	if (ret)
+		return ret;
+
+	if (high < timings->high_min || high > timings->high_max ||
+	    low < timings->low_min || low > timings->low_max)
+		return -EINVAL;
+
+	freq = DIV_ROUND_CLOSEST(1000000000, period);
+	if (freq < timings->freq_min || freq > timings->freq_max)
+		return -EINVAL;
+
+	if ((high + low) != period)
+		return -EINVAL;
+
+	*scl_high = high;
+	*scl_low = low;
+
+	return 0;
+}
+
+static void dw_i3c_timing_calc_cnt(u32 core_rate_hz, u32 high, u32 low, u8 *hcnt, u8 *lcnt)
+{
+	u32 hcnt_tmp, lcnt_tmp;
+	u32 core_period_ns;
+
+	core_period_ns = DIV_ROUND_CLOSEST(1000000000, core_rate_hz);
+	hcnt_tmp = DIV_ROUND_CLOSEST(high, core_period_ns);
+	lcnt_tmp = DIV_ROUND_CLOSEST(low, core_period_ns);
+
+	if (hcnt_tmp < SCL_I3C_TIMING_CNT_MIN)
+		*hcnt = SCL_I3C_TIMING_CNT_MIN;
+	else if (hcnt_tmp > 0xFF)
+		*hcnt = 0xFF;
+	else
+		*hcnt = (u8)hcnt_tmp;
+
+	if (lcnt_tmp < SCL_I3C_TIMING_CNT_MIN)
+		*lcnt = SCL_I3C_TIMING_CNT_MIN;
+	else if (lcnt_tmp > 0xFF)
+		*lcnt = 0xFF;
+	else
+		*lcnt = (u8)lcnt_tmp;
+}
+
 static int dw_i3c_clk_cfg(struct dw_i3c_master *master)
 {
 	unsigned long core_rate, core_period;
+	struct dw_i3c_scl_timing timings;
+	u32 high, low;
 	u32 scl_timing;
 	u8 hcnt, lcnt;
+	int ret;
 
 	core_rate = clk_get_rate(master->core_clk);
 	if (!core_rate)
@@ -527,23 +1306,51 @@
 
 	core_period = DIV_ROUND_UP(1000000000, core_rate);
 
-	hcnt = DIV_ROUND_UP(I3C_BUS_THIGH_MAX_NS, core_period) - 1;
-	if (hcnt < SCL_I3C_TIMING_CNT_MIN)
-		hcnt = SCL_I3C_TIMING_CNT_MIN;
+	/* Open-drain clock configuration */
+	timings.high = master->timings.i3c_od_scl_high;
+	timings.high_min = I3C_BUS_I3C_PP_THIGH_MIN_NS;
+	timings.high_max = DW_I3C_TIMING_MAX;
+	timings.low = master->timings.i3c_od_scl_low;
+	timings.low_min = I3C_BUS_I3C_OD_TLOW_MIN_NS;
+	timings.low_max = DW_I3C_TIMING_MAX;
+	timings.freq = master->timings.i3c_od_scl_freq;
+	timings.freq_min = DW_I3C_TIMING_MIN;
+	timings.freq_max = I3C_BUS_TYP_I3C_SCL_RATE;
+	ret = dw_i3c_timing_calc(&timings, &high, &low);
+	if (ret)
+		return ret;
+
+	dw_i3c_timing_calc_cnt(core_rate, high, low, &hcnt,
+			       &lcnt);
+	scl_timing = SCL_I3C_TIMING_HCNT(hcnt) | SCL_I3C_TIMING_LCNT(lcnt);
+	writel(scl_timing, master->regs + SCL_I3C_OD_TIMING);
 
-	lcnt = DIV_ROUND_UP(core_rate, I3C_BUS_TYP_I3C_SCL_RATE) - hcnt;
-	if (lcnt < SCL_I3C_TIMING_CNT_MIN)
-		lcnt = SCL_I3C_TIMING_CNT_MIN;
+	/* SDR0 (push-pull) clock configuration */
+	timings.high = master->timings.i3c_pp_scl_high;
+	timings.high_min = I3C_BUS_I3C_PP_THIGH_MIN_NS;
+	timings.high_max = DW_I3C_TIMING_MAX;
+	timings.low = master->timings.i3c_pp_scl_low;
+	timings.low_min = I3C_BUS_I3C_PP_TLOW_MIN_NS;
+	timings.low_max = DW_I3C_TIMING_MAX;
+	timings.freq = master->timings.i3c_pp_scl_freq;
+	timings.freq_min = DW_I3C_TIMING_MIN;
+	timings.freq_max = I3C_BUS_TYP_I3C_SCL_RATE;
+	ret = dw_i3c_timing_calc(&timings, &high, &low);
+	if (ret)
+		return ret;
 
+	dw_i3c_timing_calc_cnt(core_rate, high, low, &hcnt,
+			       &lcnt);
 	scl_timing = SCL_I3C_TIMING_HCNT(hcnt) | SCL_I3C_TIMING_LCNT(lcnt);
 	writel(scl_timing, master->regs + SCL_I3C_PP_TIMING);
 
 	if (!(readl(master->regs + DEVICE_CTRL) & DEV_CTRL_I2C_SLAVE_PRESENT))
 		writel(BUS_I3C_MST_FREE(lcnt), master->regs + BUS_FREE_TIMING);
 
-	lcnt = DIV_ROUND_UP(I3C_BUS_TLOW_OD_MIN_NS, core_period);
-	scl_timing = SCL_I3C_TIMING_HCNT(hcnt) | SCL_I3C_TIMING_LCNT(lcnt);
-	writel(scl_timing, master->regs + SCL_I3C_OD_TIMING);
+	/* SDR1, SDR2, SDR3, SDR4 (push-pull) clocks configuration */
+	hcnt = DIV_ROUND_UP(I3C_BUS_I3C_OD_THIGH_MAX_NS, core_period) - 1;
+	if (hcnt < SCL_I3C_TIMING_CNT_MIN)
+		hcnt = SCL_I3C_TIMING_CNT_MIN;
 
 	lcnt = DIV_ROUND_UP(core_rate, I3C_BUS_SDR1_SCL_RATE) - hcnt;
 	scl_timing = SCL_EXT_LCNT_1(lcnt);
@@ -555,6 +1362,9 @@
 	scl_timing |= SCL_EXT_LCNT_4(lcnt);
 	writel(scl_timing, master->regs + SCL_EXT_LCNT_TIMING);
 
+	master->timings.i3c_core_rate = core_rate;
+	master->timings.i3c_core_period = core_period;
+
 	return 0;
 }
 
@@ -589,12 +1399,31 @@
 	return 0;
 }
 
-static int dw_i3c_master_bus_init(struct i3c_master_controller *m)
+static int dw_sda_tx_hold_cfg(struct dw_i3c_master *master)
+{
+	unsigned long core_rate, core_period;
+	u8 sda_tx_hold;
+
+	/* Do not modify register if there is no DT configuration or 0 was provied */
+	if (!master->timings.sda_tx_hold)
+		return 0;
+
+	core_rate = clk_get_rate(master->core_clk);
+	if (!core_rate)
+		return -EINVAL;
+
+	core_period = DIV_ROUND_UP(1000000000, core_rate);
+	sda_tx_hold = clamp((u32)DIV_ROUND_CLOSEST(master->timings.sda_tx_hold, core_period),
+			    (u32)SDA_TX_HOLD_MIN, (u32)SDA_TX_HOLD_MAX);
+	writel(SDA_TX_HOLD(sda_tx_hold), master->regs + SDA_HOLD_SWITCH_DLY_TIMING);
+
+	return 0;
+}
+
+static int dw_i3c_bus_clk_cfg(struct i3c_master_controller *m)
 {
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 	struct i3c_bus *bus = i3c_master_get_bus(m);
-	struct i3c_device_info info = { };
-	u32 thld_ctrl;
 	int ret;
 
 	switch (bus->mode) {
@@ -613,6 +1442,122 @@
 		return -EINVAL;
 	}
 
+	return 0;
+}
+
+static int dw_i3c_target_bus_init(struct i3c_master_controller *m)
+{
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	struct i3c_dev_desc *desc = master->base.this;
+	void *rx_buf;
+	u32 reg, wait_enable_us;
+	int ret;
+
+	if (master->platform_ops && master->platform_ops->init) {
+		ret = master->platform_ops->init(master);
+		if (ret)
+			return ret;
+	}
+
+	ret = dw_i3c_bus_clk_cfg(m);
+	if (ret)
+		return ret;
+
+	reg = readl(master->regs + SLV_MAX_LEN);
+	/*
+	 * Set max private write length value based on read-only register.
+	 * TODO: Handle updates after receiving SETMWL CCC.
+	 */
+	master->target_rx.max_len = SLV_MAX_WR_LEN(reg);
+
+	rx_buf = kzalloc(master->target_rx.max_len, GFP_KERNEL);
+	if (!rx_buf)
+		return -ENOMEM;
+
+	master->target_rx.buf = rx_buf;
+
+	dw_i3c_master_disable(master);
+
+	reg = readl(master->regs + QUEUE_THLD_CTRL) & ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
+	writel(reg, master->regs + QUEUE_THLD_CTRL);
+
+	reg = readl(master->regs + DATA_BUFFER_THLD_CTRL) & ~DATA_BUFFER_THLD_CTRL_RX_BUF;
+	writel(reg, master->regs + DATA_BUFFER_THLD_CTRL);
+
+	writel(INTR_ALL, master->regs + INTR_STATUS);
+	writel(INTR_TARGET_MASK, master->regs + INTR_STATUS_EN);
+	writel(INTR_TARGET_MASK, master->regs + INTR_SIGNAL_EN);
+
+	reg = readl(master->regs + DEVICE_CTRL_EXTENDED) & ~DEVICE_CTRL_EXTENDED_MODE_MASK;
+	reg |= DEVICE_CTRL_EXTENDED_MODE(DEV_OPERATION_MODE_TARGET);
+	writel(reg, master->regs + DEVICE_CTRL_EXTENDED);
+
+	writel(SLV_PID_LO(desc->info.pid), master->regs + SLV_PID_VALUE);
+	writel(SLV_PID_HI(desc->info.pid), master->regs + SLV_MIPI_ID_VALUE);
+
+	reg = readl(master->regs + SLV_CHAR_CTRL) & ~SLV_DCR_MASK & ~SLV_DEVICE_ROLE_MASK;
+	reg |= SLV_DCR(desc->info.dcr) | SLV_DEVICE_ROLE(0);
+	writel(reg, master->regs + SLV_CHAR_CTRL);
+
+	reg = readl(master->regs + BUS_FREE_TIMING) | BUS_AVAIL_TIME(MAX_BUS_AVAIL_CNT);
+	writel(reg, master->regs + BUS_FREE_TIMING);
+
+	reg = readl(master->regs + SLV_EVENT_CTRL);
+	reg &= ~SLV_EVENT_CTRL_HJ_EN;
+	writel(reg, master->regs + SLV_EVENT_CTRL);
+	writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_IBI_PAYLOAD_EN,
+	       master->regs + DEVICE_CTRL);
+
+	if (master->platform_ops && master->platform_ops->isolate_scl_sda)
+		master->platform_ops->isolate_scl_sda(master, true);
+	dw_i3c_master_enable(master);
+	wait_enable_us = DIV_ROUND_UP(master->timings.i3c_core_period *
+				      BUS_AVAIL_TIME_GET(readl(master->regs + BUS_FREE_TIMING)),
+				      NSEC_PER_USEC);
+	udelay(wait_enable_us);
+	if (!dw_i3c_master_poll_enable_bit(master)) {
+		dev_warn(master->dev, "Target bus init: failed to enable controller");
+		ret = -EACCES;
+	}
+
+	if (master->platform_ops && master->platform_ops->gen_stop_to_internal)
+		master->platform_ops->gen_stop_to_internal(master);
+
+	if (master->platform_ops && master->platform_ops->isolate_scl_sda)
+		master->platform_ops->isolate_scl_sda(master, false);
+
+	return ret;
+}
+
+static void dw_i3c_target_bus_cleanup(struct i3c_master_controller *m)
+{
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+
+	dw_i3c_master_disable(master);
+	kfree(master->target_rx.buf);
+}
+
+static int dw_i3c_master_bus_init(struct i3c_master_controller *m)
+{
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	struct i3c_device_info info = { };
+	u32 thld_ctrl;
+	int ret;
+
+	if (master->platform_ops && master->platform_ops->init) {
+		ret = master->platform_ops->init(master);
+		if (ret)
+			return ret;
+	}
+
+	ret = dw_i3c_bus_clk_cfg(m);
+	if (ret)
+		return ret;
+
+	ret = dw_sda_tx_hold_cfg(master);
+	if (ret)
+		return ret;
+
 	thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
 	thld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
 	writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
@@ -621,10 +1566,18 @@
 	thld_ctrl &= ~DATA_BUFFER_THLD_CTRL_RX_BUF;
 	writel(thld_ctrl, master->regs + DATA_BUFFER_THLD_CTRL);
 
+	if (master->ver_type >= I3C_LC_RELEASE) {
+		thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+		thld_ctrl &= ~(QUEUE_THLD_CTRL_IBI_STA_MASK | QUEUE_THLD_CTRL_IBI_DAT_MASK);
+		thld_ctrl |= QUEUE_THLD_CTRL_IBI_STA(1) | QUEUE_THLD_CTRL_IBI_DAT(1);
+		writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
+	}
+
 	writel(INTR_ALL, master->regs + INTR_STATUS);
 	writel(INTR_MASTER_MASK, master->regs + INTR_STATUS_EN);
 	writel(INTR_MASTER_MASK, master->regs + INTR_SIGNAL_EN);
 
+
 	ret = i3c_master_get_free_addr(m, 0);
 	if (ret < 0)
 		return ret;
@@ -646,6 +1599,10 @@
 	writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_HOT_JOIN_NACK,
 	       master->regs + DEVICE_CTRL);
 
+	if (!master->base.jdec_spd)
+		writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_IBA_INCLUDE,
+		       master->regs + DEVICE_CTRL);
+
 	dw_i3c_master_enable(master);
 
 	return 0;
@@ -663,12 +1620,17 @@
 {
 	struct dw_i3c_xfer *xfer;
 	struct dw_i3c_cmd *cmd;
+	int hw_dat_index = 0;
 	int ret, pos = 0;
 
 	if (ccc->id & I3C_CCC_DIRECT) {
 		pos = dw_i3c_master_get_addr_pos(master, ccc->dests[0].addr);
 		if (pos < 0)
 			return pos;
+
+		hw_dat_index = dw_i3c_master_alloc_and_get_hw_dat_index(master, pos);
+		if (hw_dat_index < 0)
+			return hw_dat_index;
 	}
 
 	xfer = dw_i3c_master_alloc_xfer(master, 1);
@@ -683,11 +1645,14 @@
 		      COMMAND_PORT_TRANSFER_ARG;
 
 	cmd->cmd_lo = COMMAND_PORT_CP |
-		      COMMAND_PORT_DEV_INDEX(pos) |
+		      COMMAND_PORT_DEV_INDEX(hw_dat_index) |
 		      COMMAND_PORT_CMD(ccc->id) |
 		      COMMAND_PORT_TOC |
 		      COMMAND_PORT_ROC;
 
+	dev_dbg(master->dev, "%s:cmd_hi=0x%08x cmd_lo=0x%08x tx_len=%d id=%x\n",
+		__func__, cmd->cmd_hi, cmd->cmd_lo, cmd->tx_len, ccc->id);
+
 	dw_i3c_master_enqueue_xfer(master, xfer);
 	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
 		dw_i3c_master_dequeue_xfer(master, xfer);
@@ -705,12 +1670,17 @@
 {
 	struct dw_i3c_xfer *xfer;
 	struct dw_i3c_cmd *cmd;
+	int hw_dat_index = 0;
 	int ret, pos;
 
 	pos = dw_i3c_master_get_addr_pos(master, ccc->dests[0].addr);
 	if (pos < 0)
 		return pos;
 
+	hw_dat_index = dw_i3c_master_alloc_and_get_hw_dat_index(master, pos);
+	if (hw_dat_index < 0)
+		return hw_dat_index;
+
 	xfer = dw_i3c_master_alloc_xfer(master, 1);
 	if (!xfer)
 		return -ENOMEM;
@@ -724,11 +1694,14 @@
 
 	cmd->cmd_lo = COMMAND_PORT_READ_TRANSFER |
 		      COMMAND_PORT_CP |
-		      COMMAND_PORT_DEV_INDEX(pos) |
+		      COMMAND_PORT_DEV_INDEX(hw_dat_index) |
 		      COMMAND_PORT_CMD(ccc->id) |
 		      COMMAND_PORT_TOC |
 		      COMMAND_PORT_ROC;
 
+	dev_dbg(master->dev, "%s:cmd_hi=0x%08x cmd_lo=0x%08x rx_len=%d id=%x\n",
+		__func__, cmd->cmd_hi, cmd->cmd_lo, cmd->rx_len, ccc->id);
+
 	dw_i3c_master_enqueue_xfer(master, xfer);
 	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
 		dw_i3c_master_dequeue_xfer(master, xfer);
@@ -746,61 +1719,59 @@
 {
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 	int ret = 0;
+	u32 i3c_pp_timing, i3c_od_timing;
 
 	if (ccc->id == I3C_CCC_ENTDAA)
 		return -EINVAL;
 
+	i3c_od_timing = readl(master->regs + SCL_I3C_OD_TIMING);
+	i3c_pp_timing = readl(master->regs + SCL_I3C_PP_TIMING);
+	if ((ccc->id == I3C_CCC_SETAASA) || (ccc->id == I3C_CCC_SETHID) ||
+	    (ccc->id == I3C_CCC_DEVCTRL)) {
+		writel(i3c_od_timing, master->regs + SCL_I3C_PP_TIMING);
+	}
+
 	if (ccc->rnw)
 		ret = dw_i3c_ccc_get(master, ccc);
 	else
 		ret = dw_i3c_ccc_set(master, ccc);
 
+	if ((ccc->id == I3C_CCC_SETAASA) || (ccc->id == I3C_CCC_SETHID))
+		writel(i3c_pp_timing, master->regs + SCL_I3C_PP_TIMING);
+
 	return ret;
 }
 
-static int dw_i3c_master_daa(struct i3c_master_controller *m)
+static int dw_i3c_master_daa_single(struct i3c_master_controller *m)
 {
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 	struct dw_i3c_xfer *xfer;
 	struct dw_i3c_cmd *cmd;
-	u32 olddevs, newdevs;
-	u8 p, last_addr = 0;
-	int ret, pos;
-
-	olddevs = ~(master->free_pos);
+	u8 addrs[MAX_DEVS];
+	int last_addr = 0;
+	int newdevs;
+	int index;
 
 	/* Prepare DAT before launching DAA. */
-	for (pos = 0; pos < master->maxdevs; pos++) {
-		if (olddevs & BIT(pos))
-			continue;
-
-		ret = i3c_master_get_free_addr(m, last_addr + 1);
-		if (ret < 0)
+	for (index = 0; index < master->dat_depth; index++) {
+		last_addr = i3c_master_get_free_addr(m, last_addr + 1);
+		if (last_addr < 0)
 			return -ENOSPC;
 
-		master->addrs[pos] = ret;
-		p = even_parity(ret);
-		last_addr = ret;
-		ret |= (p << 7);
-
-		writel(DEV_ADDR_TABLE_DYNAMIC_ADDR(ret),
-		       master->regs +
-		       DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));
+		addrs[index] = last_addr;
+		writel(DEV_ADDR_TABLE_DYNAMIC_ADDR_PARITY(even_parity(last_addr)) |
+		       DEV_ADDR_TABLE_DYNAMIC_ADDR(last_addr),
+		       master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, index));
 	}
 
 	xfer = dw_i3c_master_alloc_xfer(master, 1);
 	if (!xfer)
 		return -ENOMEM;
 
-	pos = dw_i3c_master_get_free_pos(master);
-	if (pos < 0) {
-		dw_i3c_master_free_xfer(xfer);
-		return pos;
-	}
 	cmd = &xfer->cmds[0];
 	cmd->cmd_hi = 0x1;
-	cmd->cmd_lo = COMMAND_PORT_DEV_COUNT(master->maxdevs - pos) |
-		      COMMAND_PORT_DEV_INDEX(pos) |
+	cmd->cmd_lo = COMMAND_PORT_DEV_COUNT(master->dat_depth) |
+		      COMMAND_PORT_DEV_INDEX(0) |
 		      COMMAND_PORT_CMD(I3C_CCC_ENTDAA) |
 		      COMMAND_PORT_ADDR_ASSGN_CMD |
 		      COMMAND_PORT_TOC |
@@ -810,17 +1781,43 @@
 	if (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))
 		dw_i3c_master_dequeue_xfer(master, xfer);
 
-	newdevs = GENMASK(master->maxdevs - cmd->rx_len - 1, 0);
-	newdevs &= ~olddevs;
-
-	for (pos = 0; pos < master->maxdevs; pos++) {
-		if (newdevs & BIT(pos))
-			i3c_master_add_i3c_dev_locked(m, master->addrs[pos]);
-	}
+	newdevs = master->dat_depth - cmd->rx_len;
 
 	dw_i3c_master_free_xfer(xfer);
 
-	return 0;
+	for (index = 0; index < newdevs; index++)
+		i3c_master_add_i3c_dev_locked(m, addrs[index]);
+
+	if (master->sw_dat_enabled)
+		dw_i3c_master_unlink_hw_dat(master, DEVICE_ADDR_TABLE_COMMON_SLOT);
+
+	return newdevs;
+}
+
+static int dw_i3c_master_daa(struct i3c_master_controller *m)
+{
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	u32 hw_dat[MAX_DEVS];
+	int index;
+	int ret;
+
+	/* Save DAT before DAA */
+	for (index = 0; index < master->dat_depth; ++index)
+		hw_dat[index] = readl(master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr,
+									index));
+
+	do {
+		ret = dw_i3c_master_daa_single(m);
+		if (ret < 0)
+			break;
+	} while (ret == master->dat_depth);
+
+	/* Restore DAT after DAA */
+	for (index = 0; index < master->dat_depth; ++index)
+		writel(hw_dat[index], master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr,
+									index));
+
+	return (ret < 0) ? ret : 0;
 }
 
 static int dw_i3c_master_priv_xfers(struct i3c_dev_desc *dev,
@@ -832,8 +1829,13 @@
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 	unsigned int nrxwords = 0, ntxwords = 0;
 	struct dw_i3c_xfer *xfer;
+	int hw_dat_index;
 	int i, ret = 0;
 
+	hw_dat_index = dw_i3c_master_alloc_and_get_hw_dat_index(master, data->index);
+	if (hw_dat_index < 0)
+		return hw_dat_index;
+
 	if (!i3c_nxfers)
 		return 0;
 
@@ -864,22 +1866,30 @@
 		if (i3c_xfers[i].rnw) {
 			cmd->rx_buf = i3c_xfers[i].data.in;
 			cmd->rx_len = i3c_xfers[i].len;
-			cmd->cmd_lo = COMMAND_PORT_READ_TRANSFER |
+			cmd->cmd_lo = COMMAND_PORT_TID(TID_MASTER_READ) |
+				      COMMAND_PORT_READ_TRANSFER |
 				      COMMAND_PORT_SPEED(dev->info.max_read_ds);
 
 		} else {
 			cmd->tx_buf = i3c_xfers[i].data.out;
 			cmd->tx_len = i3c_xfers[i].len;
-			cmd->cmd_lo =
-				COMMAND_PORT_SPEED(dev->info.max_write_ds);
+			cmd->cmd_lo = COMMAND_PORT_TID(TID_MASTER_WRITE) |
+				      COMMAND_PORT_SPEED(dev->info.max_write_ds);
 		}
 
-		cmd->cmd_lo |= COMMAND_PORT_TID(i) |
-			       COMMAND_PORT_DEV_INDEX(data->index) |
+		cmd->cmd_lo |= COMMAND_PORT_DEV_INDEX(hw_dat_index) |
 			       COMMAND_PORT_ROC;
 
 		if (i == (i3c_nxfers - 1))
 			cmd->cmd_lo |= COMMAND_PORT_TOC;
+
+		if (dev->info.pec)
+			cmd->cmd_lo |= COMMAND_PORT_PEC;
+
+		dev_dbg(master->dev,
+			"%s:cmd_hi=0x%08x cmd_lo=0x%08x tx_len=%d rx_len=%d\n",
+			__func__, cmd->cmd_hi, cmd->cmd_lo, cmd->tx_len,
+			cmd->rx_len);
 	}
 
 	dw_i3c_master_enqueue_xfer(master, xfer);
@@ -887,68 +1897,271 @@
 		dw_i3c_master_dequeue_xfer(master, xfer);
 
 	ret = xfer->ret;
+	if (ret)
+		goto out;
+
+	for (i = 0; i < i3c_nxfers; i++)
+		if (i3c_xfers[i].rnw)
+			i3c_xfers[i].len = xfer->cmds[i].rx_len;
+out:
 	dw_i3c_master_free_xfer(xfer);
 
 	return ret;
 }
 
-static int dw_i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev,
-					  u8 old_dyn_addr)
+static int dw_i3c_target_priv_xfers(struct i3c_dev_desc *dev,
+				    struct i3c_priv_xfer *i3c_xfers,
+				    int i3c_nxfers)
 {
-	struct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
 	struct i3c_master_controller *m = i3c_dev_get_master(dev);
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
-	int pos;
+	struct dw_i3c_xfer *xfer;
+	int i;
 
-	pos = dw_i3c_master_get_free_pos(master);
+	if (!i3c_nxfers)
+		return 0;
+
+	if (i3c_nxfers > master->caps.cmdfifodepth)
+		return -EOPNOTSUPP;
 
-	if (data->index > pos && pos > 0) {
-		writel(0,
-		       master->regs +
-		       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	xfer = dw_i3c_master_alloc_xfer(master, i3c_nxfers);
+	if (!xfer)
+		return -ENOMEM;
 
-		master->addrs[data->index] = 0;
-		master->free_pos |= BIT(data->index);
+	for (i = 0; i < i3c_nxfers; i++) {
+		struct dw_i3c_cmd *cmd = &xfer->cmds[i];
 
-		data->index = pos;
-		master->addrs[pos] = dev->info.dyn_addr;
-		master->free_pos &= ~BIT(pos);
+		if (!i3c_xfers[i].rnw) {
+			cmd->tx_buf = i3c_xfers[i].data.out;
+			cmd->tx_len = i3c_xfers[i].len;
+			cmd->cmd_lo = 0 | COMMAND_PORT_TID(TID_MASTER_READ) | (cmd->tx_len << 16);
+
+			dw_i3c_master_wr_tx_fifo(master, cmd->tx_buf, cmd->tx_len);
+			writel(cmd->cmd_lo, master->regs + COMMAND_QUEUE_PORT);
+		}
+	}
+
+	dw_i3c_master_free_xfer(xfer);
+
+	return 0;
+}
+
+static int dw_i3c_target_generate_ibi(struct i3c_dev_desc *dev, const u8 *data, int len)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	u32 reg, thld_ctrl;
+
+	reg = readl(master->regs + SLV_EVENT_CTRL);
+	if ((reg & SLV_EVENT_CTRL_SIR_EN) == 0)
+		return -EPERM;
+
+	if (len > AST2600_I3C_IBI_MAX_PAYLOAD) {
+		dev_err(master->dev,
+			"input length %d exceeds max ibi payload size %d\n",
+			len, AST2600_I3C_IBI_MAX_PAYLOAD);
+		return -E2BIG;
+	}
+
+	init_completion(&master->ibi.target.comp);
+
+	reg = readl(master->regs + DEVICE_CTRL);
+	reg &= ~DEV_CTRL_IBI_TRGT_MDB_MASK;
+	reg |= DEV_CTRL_IBI_TRGT_MDB(data[0]);
+	writel(reg, master->regs + DEVICE_CTRL);
+
+	dw_i3c_master_wr_tx_fifo(master, data, len);
+
+	reg = FIELD_PREP(COMMAND_PORT_SLAVE_DATA_LEN, len) |
+			 COMMAND_PORT_SLAVE_TID(TID_SLAVE_IBI);
+	writel(reg, master->regs + COMMAND_QUEUE_PORT);
+
+	thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+	thld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
+	thld_ctrl |= QUEUE_THLD_CTRL_RESP_BUF(1);
+	writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
+
+	writel(1, master->regs + SLV_INTR_REQ);
+
+	if (!wait_for_completion_timeout(&master->ibi.target.comp, XFER_TIMEOUT)) {
+		pr_warn("timeout waiting for completion\n");
+		writel(RESET_CTRL_RX_FIFO | RESET_CTRL_TX_FIFO |
+		       RESET_CTRL_RESP_QUEUE | RESET_CTRL_CMD_QUEUE, master->regs + RESET_CTRL);
+		return -EINVAL;
+	}
+
+	reg = readl(master->regs + SLV_INTR_REQ);
+	if (SLV_INTR_REQ_IBI_STS(reg) != IBI_STS_ACCEPTED) {
+		reg = readl(master->regs + SLV_EVENT_CTRL);
+		if ((reg & SLV_EVENT_CTRL_SIR_EN) == 0)
+			pr_warn("sir is disabled by master\n");
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+static int dw_i3c_target_cleanup_ctrl_queues_on_timeout(struct dw_i3c_master *master)
+{
+	u32 wait_enable_us;
+	int ret = 0;
+
+	if (master->platform_ops && master->platform_ops->isolate_scl_sda)
+		master->platform_ops->isolate_scl_sda(master, true);
+
+	dw_i3c_master_disable(master);
+	if (dw_i3c_master_poll_enable_bit(master)) {
+		dev_warn(master->dev, "Master read timeout: failed to disable controller");
+		ret = -EACCES;
+		goto reset_finished;
+	}
+
+	writel(RESET_CTRL_QUEUES, master->regs + RESET_CTRL);
+	dw_i3c_master_enable(master);
+	wait_enable_us = DIV_ROUND_UP(master->timings.i3c_core_period *
+				      BUS_AVAIL_TIME_GET(readl(master->regs + BUS_FREE_TIMING)),
+				      NSEC_PER_USEC);
+	udelay(wait_enable_us);
+	if (!dw_i3c_master_poll_enable_bit(master)) {
+		dev_warn(master->dev, "Master read timeout: failed to enable controller");
+		ret = -EACCES;
+	}
+
+reset_finished:
+	if (master->platform_ops && master->platform_ops->isolate_scl_sda)
+		master->platform_ops->isolate_scl_sda(master, false);
+	return ret;
+}
+
+static int dw_i3c_target_put_read_data(struct i3c_dev_desc *dev, struct i3c_priv_xfer *i3c_xfers,
+				       int i3c_nxfers, const u8 *ibi_data, int ibi_len)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	struct dw_i3c_xfer *xfer;
+	u32 reg, thld_ctrl;
+	int i, ibi_notify, ret = 0;
+
+	if (!i3c_nxfers)
+		return 0;
+
+	if (i3c_nxfers > master->caps.cmdfifodepth)
+		return -EOPNOTSUPP;
+
+	xfer = dw_i3c_master_alloc_xfer(master, i3c_nxfers);
+	if (!xfer)
+		return -ENOMEM;
+
+	ibi_notify = ibi_data && ibi_len <= AST2600_I3C_IBI_MAX_PAYLOAD;
+	reg = readl(master->regs + SLV_EVENT_CTRL);
+	if ((reg & SLV_EVENT_CTRL_SIR_EN) == 0)
+		ibi_notify = 0;
+
+	if (ibi_notify) {
+		init_completion(&master->ibi.target.comp);
+
+		reg = readl(master->regs + DEVICE_CTRL);
+		reg &= ~DEV_CTRL_IBI_TRGT_MDB_MASK;
+		reg |= DEV_CTRL_IBI_TRGT_MDB(ibi_data[0]);
+		writel(reg, master->regs + DEVICE_CTRL);
+
+		dw_i3c_master_wr_tx_fifo(master, ibi_data, ibi_len);
+
+		reg = FIELD_PREP(COMMAND_PORT_SLAVE_DATA_LEN, ibi_len) |
+				 COMMAND_PORT_SLAVE_TID(TID_SLAVE_IBI);
+		writel(reg, master->regs + COMMAND_QUEUE_PORT);
+
+		thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+		thld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
+		thld_ctrl |= QUEUE_THLD_CTRL_RESP_BUF(1);
+		writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
+	}
+
+	init_completion(&master->target_read_comp);
+	for (i = 0; i < i3c_nxfers; i++) {
+		struct dw_i3c_cmd *cmd = &xfer->cmds[i];
+
+		if (!i3c_xfers[i].rnw) {
+			cmd->tx_buf = i3c_xfers[i].data.out;
+			cmd->tx_len = i3c_xfers[i].len;
+			cmd->cmd_lo = 0 | COMMAND_PORT_TID(TID_MASTER_READ) | (cmd->tx_len << 16);
+
+			dw_i3c_master_wr_tx_fifo(master, cmd->tx_buf, cmd->tx_len);
+			writel(cmd->cmd_lo, master->regs + COMMAND_QUEUE_PORT);
+		}
+	}
+
+	if (ibi_notify) {
+		writel(1, master->regs + SLV_INTR_REQ);
+		if (!wait_for_completion_timeout(&master->ibi.target.comp,
+						 XFER_TIMEOUT)) {
+			dev_err(master->dev, "send sir timeout\n");
+			writel(RESET_CTRL_QUEUES, master->regs + RESET_CTRL);
+		}
+
+		reg = readl(master->regs + SLV_INTR_REQ);
+		if (SLV_INTR_REQ_IBI_STS(reg) != IBI_STS_ACCEPTED) {
+			reg = readl(master->regs + SLV_EVENT_CTRL);
+			if ((reg & SLV_EVENT_CTRL_SIR_EN) == 0)
+				pr_warn("sir is disabled by master\n");
+		}
 	}
 
-	writel(DEV_ADDR_TABLE_DYNAMIC_ADDR(dev->info.dyn_addr),
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	if (!wait_for_completion_timeout(&master->target_read_comp, master->target_read_timeout))
+		ret = dw_i3c_target_cleanup_ctrl_queues_on_timeout(master);
+
+	dw_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
 
-	master->addrs[data->index] = dev->info.dyn_addr;
+static u8 dw_i3c_target_get_dyn_addr(struct i3c_master_controller *m)
+{
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	u32 reg;
 
+	reg = readl(master->regs + DEVICE_ADDR);
+	if (reg & DEV_ADDR_DYNAMIC_ADDR_VALID)
+		return DEV_ADDR_DYNAMIC_GET(reg);
 	return 0;
 }
 
+static int dw_i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev,
+					  u8 old_dyn_addr)
+{
+	struct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+
+	return dw_i3c_master_update_i3c_dev(master, dev->info.dyn_addr, data->index);
+}
+
 static int dw_i3c_master_attach_i3c_dev(struct i3c_dev_desc *dev)
 {
 	struct i3c_master_controller *m = i3c_dev_get_master(dev);
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 	struct dw_i3c_i2c_dev_data *data;
 	int pos;
+	int ret;
 
-	pos = dw_i3c_master_get_free_pos(master);
-	if (pos < 0)
-		return pos;
+	pos = dw_i3c_master_get_addr_pos(master, dev->info.dyn_addr ? : dev->info.static_addr);
+	if (pos < 0) {
+		pos = dw_i3c_master_get_free_pos(master);
+		if (pos < 0)
+			return pos;
+	}
 
 	data = kzalloc(sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
-	data->index = pos;
-	master->addrs[pos] = dev->info.dyn_addr ? : dev->info.static_addr;
-	master->free_pos &= ~BIT(pos);
-	i3c_dev_set_master_data(dev, data);
-
-	writel(DEV_ADDR_TABLE_DYNAMIC_ADDR(master->addrs[pos]),
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	ret = dw_i3c_master_add_i3c_dev(master, dev->info.dyn_addr ? : dev->info.static_addr, pos);
+	if (!ret) {
+		data->index = pos;
+		i3c_dev_set_master_data(dev, data);
+	}
 
-	return 0;
+	return ret;
 }
 
 static void dw_i3c_master_detach_i3c_dev(struct i3c_dev_desc *dev)
@@ -957,13 +2170,8 @@
 	struct i3c_master_controller *m = i3c_dev_get_master(dev);
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 
-	writel(0,
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
-
+	dw_i3c_master_remove_dev(master, data->index);
 	i3c_dev_set_master_data(dev, NULL);
-	master->addrs[data->index] = 0;
-	master->free_pos |= BIT(data->index);
 	kfree(data);
 }
 
@@ -976,8 +2184,13 @@
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 	unsigned int nrxwords = 0, ntxwords = 0;
 	struct dw_i3c_xfer *xfer;
+	int hw_dat_index;
 	int i, ret = 0;
 
+	hw_dat_index = dw_i3c_master_alloc_and_get_hw_dat_index(master, data->index);
+	if (hw_dat_index < 0)
+		return hw_dat_index;
+
 	if (!i2c_nxfers)
 		return 0;
 
@@ -1005,15 +2218,16 @@
 		cmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(i2c_xfers[i].len) |
 			COMMAND_PORT_TRANSFER_ARG;
 
-		cmd->cmd_lo = COMMAND_PORT_TID(i) |
-			      COMMAND_PORT_DEV_INDEX(data->index) |
+		cmd->cmd_lo = COMMAND_PORT_DEV_INDEX(hw_dat_index) |
 			      COMMAND_PORT_ROC;
 
 		if (i2c_xfers[i].flags & I2C_M_RD) {
-			cmd->cmd_lo |= COMMAND_PORT_READ_TRANSFER;
+			cmd->cmd_lo |= COMMAND_PORT_TID(TID_MASTER_READ) |
+				       COMMAND_PORT_READ_TRANSFER;
 			cmd->rx_buf = i2c_xfers[i].buf;
 			cmd->rx_len = i2c_xfers[i].len;
 		} else {
+			cmd->cmd_lo |= COMMAND_PORT_TID(TID_MASTER_WRITE);
 			cmd->tx_buf = i2c_xfers[i].buf;
 			cmd->tx_len = i2c_xfers[i].len;
 		}
@@ -1032,12 +2246,184 @@
 	return ret;
 }
 
+static void dw_i3c_master_enable_ibi_irq(struct dw_i3c_master *master)
+{
+	u32 reg;
+
+	reg = readl(master->regs + INTR_STATUS_EN);
+	reg |= INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_STATUS_EN);
+
+	reg = readl(master->regs + INTR_SIGNAL_EN);
+	reg |= INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_SIGNAL_EN);
+}
+
+static void dw_i3c_master_disable_ibi_irq(struct dw_i3c_master *master)
+{
+	u32 reg;
+
+	reg = readl(master->regs + INTR_STATUS_EN);
+	reg &= ~INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_STATUS_EN);
+
+	reg = readl(master->regs + INTR_SIGNAL_EN);
+	reg &= ~INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_SIGNAL_EN);
+}
+
+static int dw_i3c_master_request_ibi(struct i3c_dev_desc *dev,
+				     const struct i3c_ibi_setup *req)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	struct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+	unsigned int i;
+
+	if (master->ver_type < I3C_LC_RELEASE)
+		return -EOPNOTSUPP;
+
+	data->ibi_pool = i3c_generic_ibi_alloc_pool(dev, req);
+	if (IS_ERR(data->ibi_pool))
+		return PTR_ERR(data->ibi_pool);
+
+	spin_lock_irq(&master->ibi.master.lock);
+	for (i = 0; i < master->maxdevs; i++) {
+		if (!master->ibi.master.slots[i]) {
+			data->ibi = i;
+			master->ibi.master.slots[i] = dev;
+			master->ibi.master.received_ibi_len[i] = 0;
+			break;
+		}
+	}
+	spin_unlock_irq(&master->ibi.master.lock);
+
+	if (i >= master->maxdevs) {
+		i3c_generic_ibi_free_pool(data->ibi_pool);
+		data->ibi_pool = NULL;
+		return -ENOSPC;
+	}
+
+	return 0;
+}
+
+static int dw_i3c_master_enable_ibi(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	int ret, pos;
+	u32 reg;
+
+	pos = dw_i3c_master_get_addr_pos(master, dev->info.dyn_addr);
+	if (pos < 0)
+		return pos;
+
+	spin_lock_irq(&master->ibi.master.lock);
+
+	/*
+	 * Corresponding changes to DAT: ACK the SIR from the specific device;
+	 * One or more data bytes must be present.
+	 */
+	ret = dw_i3c_master_enable_ibi_in_dat(master, pos, dev->info.bcr & I3C_BCR_IBI_PAYLOAD);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Clean-up the bit in IBI_SIR_REQ_REJECT so that the SIR request from the specific
+	 * slave device is acknowledged by the master device.
+	 */
+	reg = readl(master->regs + IBI_SIR_REQ_REJECT) & ~BIT(dev->info.dyn_addr);
+	writel(reg, master->regs + IBI_SIR_REQ_REJECT);
+
+	spin_unlock_irq(&master->ibi.master.lock);
+
+	/* Enable SIR generation on the requested slave device */
+	ret = i3c_master_enec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);
+	if (ret) {
+		spin_lock_irq(&master->ibi.master.lock);
+		reg = readl(master->regs + IBI_SIR_REQ_REJECT);
+		reg |= BIT(dev->info.dyn_addr);
+		writel(reg, master->regs + IBI_SIR_REQ_REJECT);
+
+		dw_i3c_master_disable_ibi_in_dat(master, pos);
+		spin_unlock_irq(&master->ibi.master.lock);
+	}
+
+	reg = readl(master->regs + IBI_SIR_REQ_REJECT);
+	if (reg == IBI_REQ_REJECT_ALL)
+		dw_i3c_master_disable_ibi_irq(master);
+	else
+		dw_i3c_master_enable_ibi_irq(master);
+
+	return ret;
+}
+
+static int dw_i3c_master_disable_ibi(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	u32 reg;
+	int ret, pos;
+
+	/* Disable SIR generation on the requested slave device */
+	ret = i3c_master_disec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);
+	if (ret)
+		dev_dbg(master->dev, "DISEC CCC failed for dev %02x\n, ret = %d",
+			dev->info.dyn_addr, ret);
+
+	pos = dw_i3c_master_get_addr_pos(master, dev->info.dyn_addr);
+	if (pos < 0) {
+		dev_warn(master->dev, "Failed to get DAT addr pos for dev %02x\n",
+			 dev->info.dyn_addr);
+		return pos;
+	}
+
+	spin_lock_irq(&master->ibi.master.lock);
+	reg = readl(master->regs + IBI_SIR_REQ_REJECT);
+	reg |= BIT(dev->info.dyn_addr);
+	writel(reg, master->regs + IBI_SIR_REQ_REJECT);
+
+	dw_i3c_master_disable_ibi_in_dat(master, pos);
+
+	reg = readl(master->regs + IBI_SIR_REQ_REJECT);
+	if (reg == IBI_REQ_REJECT_ALL)
+		dw_i3c_master_disable_ibi_irq(master);
+	else
+		dw_i3c_master_enable_ibi_irq(master);
+	spin_unlock_irq(&master->ibi.master.lock);
+
+	return 0;
+}
+
+static void dw_i3c_master_free_ibi(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct dw_i3c_master *master = to_dw_i3c_master(m);
+	struct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+
+	spin_lock_irq(&master->ibi.master.lock);
+	master->ibi.master.slots[data->ibi] = NULL;
+	data->ibi = -1;
+	spin_unlock_irq(&master->ibi.master.lock);
+
+	i3c_generic_ibi_free_pool(data->ibi_pool);
+}
+
+static void dw_i3c_master_recycle_ibi_slot(struct i3c_dev_desc *dev,
+					   struct i3c_ibi_slot *slot)
+{
+	struct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);
+
+	i3c_generic_ibi_recycle_slot(data->ibi_pool, slot);
+}
+
 static int dw_i3c_master_attach_i2c_dev(struct i2c_dev_desc *dev)
 {
 	struct i3c_master_controller *m = i2c_dev_get_master(dev);
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 	struct dw_i3c_i2c_dev_data *data;
 	int pos;
+	int ret;
 
 	pos = dw_i3c_master_get_free_pos(master);
 	if (pos < 0)
@@ -1047,17 +2433,13 @@
 	if (!data)
 		return -ENOMEM;
 
-	data->index = pos;
-	master->addrs[pos] = dev->addr;
-	master->free_pos &= ~BIT(pos);
-	i2c_dev_set_master_data(dev, data);
-
-	writel(DEV_ADDR_TABLE_LEGACY_I2C_DEV |
-	       DEV_ADDR_TABLE_STATIC_ADDR(dev->addr),
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
+	ret = dw_i3c_master_add_i2c_dev(master, dev->addr, pos);
+	if (!ret) {
+		data->index = pos;
+		i2c_dev_set_master_data(dev, data);
+	}
 
-	return 0;
+	return ret;
 }
 
 static void dw_i3c_master_detach_i2c_dev(struct i2c_dev_desc *dev)
@@ -1066,37 +2448,305 @@
 	struct i3c_master_controller *m = i2c_dev_get_master(dev);
 	struct dw_i3c_master *master = to_dw_i3c_master(m);
 
-	writel(0,
-	       master->regs +
-	       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));
-
+	dw_i3c_master_remove_dev(master, data->index);
 	i2c_dev_set_master_data(dev, NULL);
-	master->addrs[data->index] = 0;
-	master->free_pos |= BIT(data->index);
 	kfree(data);
 }
 
+static struct i3c_dev_desc *dw_get_i3c_dev_by_addr(struct dw_i3c_master *master,
+						   u8 addr)
+{
+	int i;
+
+	for (i = 0; i < master->maxdevs; i++) {
+		if (master->ibi.master.slots[i] &&
+		    master->ibi.master.slots[i]->info.dyn_addr == addr)
+			return master->ibi.master.slots[i];
+	}
+	return NULL;
+}
+
+static void dw_i3c_master_sir_handler(struct dw_i3c_master *master,
+				      u32 ibi_status)
+{
+	u8 length = IBI_QUEUE_STATUS_DATA_LEN(ibi_status);
+	u8 addr = IBI_QUEUE_IBI_ADDR(ibi_status);
+	struct dw_i3c_i2c_dev_data *data;
+	struct i3c_ibi_slot *slot;
+	struct i3c_dev_desc *dev;
+	u8 mdb = I3C_MCTP_MDB;
+	u8 *buf;
+
+	dev = dw_get_i3c_dev_by_addr(master, addr);
+	if (!dev) {
+		dev_warn(master->dev, "no matching dev\n");
+		goto err;
+	}
+
+	data = i3c_dev_get_master_data(dev);
+	slot = i3c_generic_ibi_get_free_slot(data->ibi_pool);
+	if (!slot) {
+		dev_warn(master->dev, "no free ibi slot\n");
+		goto err;
+	}
+
+	master->ibi.master.received_ibi_len[addr] += length;
+	if (master->ibi.master.received_ibi_len[addr] >
+	    slot->dev->ibi->max_payload_len) {
+		dev_dbg(master->dev, "received ibi payload %d > device requested buffer %d",
+			master->ibi.master.received_ibi_len[addr],
+			slot->dev->ibi->max_payload_len);
+		goto err;
+	}
+	if (ibi_status & IBI_QUEUE_STATUS_LAST_FRAG)
+		master->ibi.master.received_ibi_len[addr] = 0;
+	buf = slot->data;
+	/* prepend ibi status */
+	memcpy(buf, &ibi_status, sizeof(ibi_status));
+	buf += sizeof(ibi_status);
+
+	if (of_property_read_bool(master->dev->of_node, "is-mng")) {
+		memcpy(buf, &mdb, sizeof(mdb));
+		buf += sizeof(mdb);
+	}
+
+	dw_i3c_master_read_ibi_fifo(master, buf, length);
+
+	slot->len = length + sizeof(ibi_status) + sizeof(mdb);
+
+	i3c_master_queue_ibi(dev, slot);
+	return;
+
+err:
+	dw_i3c_master_flush_ibi_fifo(master, length);
+	if ((PRESENT_STATE_CM_TFR_STS(readl(master->regs + PRESENT_STATE)) ==
+	     CM_TFR_STS_MASTER_SERV_IBI) && master->platform_ops &&
+	    master->platform_ops->gen_tbits_in)
+		master->platform_ops->gen_tbits_in(master);
+	master->ibi.master.received_ibi_len[addr] = 0;
+}
+
+static void dw_i3c_master_demux_ibis(struct dw_i3c_master *master)
+{
+	u32 nibi, status, intr_signal_en;
+	int i;
+
+	nibi = QUEUE_STATUS_IBI_STATUS_CNT(readl(master->regs + QUEUE_STATUS_LEVEL));
+
+	spin_lock(&master->ibi.master.lock);
+	intr_signal_en = readl(master->regs + INTR_SIGNAL_EN);
+	intr_signal_en &= ~INTR_IBI_THLD_STAT;
+	writel(intr_signal_en, master->regs + INTR_SIGNAL_EN);
+
+	for (i = 0; i < nibi; i++) {
+		status = readl(master->regs + IBI_QUEUE_STATUS);
+
+		if (status & IBI_QUEUE_STATUS_RSP_NACK)
+			dev_warn_once(master->dev, "ibi from unrecognized slave %02lx\n",
+				      IBI_QUEUE_IBI_ADDR(status));
+
+		/*
+		 * PEC error check is remove intentionally due to AST2600 HW issue.
+		 * PEC byte in IBI payload can not be checked on this hadrware.
+		 * Thus, PEC error status should be considered as valid and the
+		 * payload should be passed to IBI handler.
+		 * Please see ASPEED's errata #67 for further details
+		 */
+
+		if (IBI_TYPE_SIR(status))
+			dw_i3c_master_sir_handler(master, status);
+	}
+
+	intr_signal_en = readl(master->regs + INTR_SIGNAL_EN);
+	intr_signal_en |= INTR_IBI_THLD_STAT;
+	writel(intr_signal_en, master->regs + INTR_SIGNAL_EN);
+	spin_unlock(&master->ibi.master.lock);
+}
+
+static void dw_i3c_target_event_handler(struct dw_i3c_master *master)
+{
+	u32 event = readl(master->regs + SLV_EVENT_CTRL);
+	u32 cm_state =
+		PRESENT_STATE_CM_TFR_STS(readl(master->regs + PRESENT_STATE));
+
+	if (cm_state == CM_TFR_STS_SLAVE_HALT) {
+		dev_dbg(master->dev, "slave in halt state\n");
+		dw_i3c_master_resume(master);
+	}
+
+	if (event & SLV_EVENT_CTRL_MRL_UPD)
+		dev_dbg(master->dev, "isr: master set mrl=%d\n",
+			readl(master->regs + SLV_MAX_LEN) >> 16);
+
+	if (event & SLV_EVENT_CTRL_MWL_UPD)
+		dev_dbg(master->dev, "isr: master set mwl=%ld\n",
+			readl(master->regs + SLV_MAX_LEN) & GENMASK(15, 0));
+
+	writel(event, master->regs + SLV_EVENT_CTRL);
+}
+
+static void dw_i3c_target_handle_response_ready(struct dw_i3c_master *master)
+{
+	struct i3c_dev_desc *desc = master->base.this;
+	u32 reg = readl(master->regs + QUEUE_STATUS_LEVEL);
+	u32 nresp = QUEUE_STATUS_LEVEL_RESP(reg);
+	int i, has_error = 0;
+
+	for (i = 0; i < nresp; i++) {
+		u32 resp = readl(master->regs + RESPONSE_QUEUE_PORT);
+		u32 nbytes = RESPONSE_PORT_DATA_LEN(resp);
+
+		if (RESPONSE_PORT_SLAVE_TID(resp) == TID_MASTER_READ)
+			complete(&master->target_read_comp);
+
+		if (RESPONSE_PORT_ERR_STATUS(resp)) {
+			has_error = 1;
+			continue;
+		}
+
+		if (nbytes > master->target_rx.max_len) {
+			dev_warn(master->dev, "private write data length is larger than max\n");
+			return;
+		}
+
+		dw_i3c_master_read_rx_fifo(master, master->target_rx.buf, nbytes);
+
+		if (desc->target_info.read_handler)
+			desc->target_info.read_handler(desc->dev, master->target_rx.buf, nbytes);
+	}
+
+	if (has_error) {
+		writel(RESET_CTRL_QUEUES, master->regs + RESET_CTRL);
+		dw_i3c_master_resume(master);
+	}
+}
+
+static void dw_i3c_target_update_dyn_addr(struct dw_i3c_master *master, u8 dyn_addr)
+{
+	struct i3c_dev_desc *desc = master->base.this;
+
+	desc->info.dyn_addr = dyn_addr;
+}
+
 static irqreturn_t dw_i3c_master_irq_handler(int irq, void *dev_id)
 {
 	struct dw_i3c_master *master = dev_id;
 	u32 status;
 
 	status = readl(master->regs + INTR_STATUS);
-
 	if (!(status & readl(master->regs + INTR_STATUS_EN))) {
 		writel(INTR_ALL, master->regs + INTR_STATUS);
 		return IRQ_NONE;
 	}
 
-	spin_lock(&master->xferqueue.lock);
-	dw_i3c_master_end_xfer_locked(master, status);
-	if (status & INTR_TRANSFER_ERR_STAT)
-		writel(INTR_TRANSFER_ERR_STAT, master->regs + INTR_STATUS);
-	spin_unlock(&master->xferqueue.lock);
+	if (master->base.target) {
+		if (status & INTR_IBI_UPDATED_STAT) {
+			writel(INTR_IBI_UPDATED_STAT, master->regs + INTR_STATUS);
+			complete(&master->ibi.target.comp);
+		}
+
+		if (status & INTR_READ_REQ_RECV_STAT) {
+			/*
+			 * TODO: Pass this information to the driver to take
+			 * appropriate action.
+			 */
+			dev_dbg(master->dev,
+				"private read received from controller when cmd queue is empty\n");
+			writel(INTR_READ_REQ_RECV_STAT, master->regs + INTR_STATUS);
+		}
+
+		if (status & INTR_RESP_READY_STAT)
+			dw_i3c_target_handle_response_ready(master);
+
+		if (status & INTR_DYN_ADDR_ASSGN_STAT) {
+			u32 reg;
+
+			reg = readl(master->regs + DEVICE_ADDR);
+			if (reg & DEV_ADDR_DYNAMIC_ADDR_VALID)
+				dw_i3c_target_update_dyn_addr(master, DEV_ADDR_DYNAMIC_GET(reg));
+			writel(INTR_DYN_ADDR_ASSGN_STAT, master->regs + INTR_STATUS);
+		}
+
+		if (status & INTR_CCC_UPDATED_STAT) {
+			writel(INTR_CCC_UPDATED_STAT, master->regs + INTR_STATUS);
+			dw_i3c_target_event_handler(master);
+		}
+	}
+
+	/*
+	 * In some cases (e.g. > 1 command being processed),
+	 * AST2600 HW can set INTR_TRANSFER_ERR_STAT without INTR_RESP_READY_STAT
+	 */
+	if (status & (INTR_RESP_READY_STAT | INTR_TRANSFER_ERR_STAT)) {
+		spin_lock(&master->xferqueue.lock);
+		dw_i3c_master_end_xfer_locked(master, status);
+		if (status & INTR_TRANSFER_ERR_STAT)
+			writel(INTR_TRANSFER_ERR_STAT, master->regs + INTR_STATUS);
+		spin_unlock(&master->xferqueue.lock);
+	}
+
+	if (status & INTR_IBI_THLD_STAT)
+		dw_i3c_master_demux_ibis(master);
 
 	return IRQ_HANDLED;
 }
 
+static void dw_i3c_master_of_timings(struct dw_i3c_master *master,
+				     struct device_node *node)
+{
+	u32 val;
+
+	if (!of_property_read_u32(node, "i2c-scl-hz", &val))
+		master->timings.i3c_od_scl_freq = val;
+
+	if (!of_property_read_u32(node, "i3c-od-scl-low-ns", &val)) {
+		if (val < I3C_BUS_I3C_OD_TLOW_MIN_NS)
+			dev_warn(master->dev,
+				 "invalid i3c-od-scl-low-ns: %u, ignoring provided value\n", val);
+		else
+			master->timings.i3c_od_scl_low = val;
+	}
+
+	if (!of_property_read_u32(node, "i3c-od-scl-high-ns", &val))
+		master->timings.i3c_od_scl_high = val;
+
+	if (!of_property_read_u32(node, "i3c-scl-hz", &val))
+		master->timings.i3c_pp_scl_freq = val;
+
+	if (!of_property_read_u32(node, "i3c-pp-scl-low-ns", &val)) {
+		if (val < I3C_BUS_I3C_PP_TLOW_MIN_NS)
+			dev_warn(master->dev,
+				 "invalid i3c-pp-scl-low-ns: %u, ignoring provided value\n", val);
+		else
+			master->timings.i3c_pp_scl_low = val;
+	}
+
+	if (!of_property_read_u32(node, "i3c-pp-scl-high-ns", &val)) {
+		if (val < I3C_BUS_I3C_PP_THIGH_MIN_NS)
+			dev_warn(master->dev,
+				 "invalid i3c-pp-scl-high-ns: %u, ignoring provided value\n", val);
+		else
+			master->timings.i3c_pp_scl_high = val;
+	}
+
+	if (!of_property_read_u32(node, "sda-tx-hold-ns", &val))
+		master->timings.sda_tx_hold = val;
+
+	if (!of_property_read_u32(node, "target-read-timeout", &val))
+		master->target_read_timeout = msecs_to_jiffies(val);
+	else
+		master->target_read_timeout = TARGET_MASTER_READ_TIMEOUT;
+}
+
+static const struct i3c_target_ops dw_mipi_i3c_target_ops = {
+	.bus_init = dw_i3c_target_bus_init,
+	.bus_cleanup = dw_i3c_target_bus_cleanup,
+	.priv_xfers = dw_i3c_target_priv_xfers,
+	.generate_ibi = dw_i3c_target_generate_ibi,
+	.put_read_data = dw_i3c_target_put_read_data,
+	.get_dyn_addr = dw_i3c_target_get_dyn_addr,
+};
+
 static const struct i3c_master_controller_ops dw_mipi_i3c_ops = {
 	.bus_init = dw_i3c_master_bus_init,
 	.bus_cleanup = dw_i3c_master_bus_cleanup,
@@ -1110,17 +2760,129 @@
 	.attach_i2c_dev = dw_i3c_master_attach_i2c_dev,
 	.detach_i2c_dev = dw_i3c_master_detach_i2c_dev,
 	.i2c_xfers = dw_i3c_master_i2c_xfers,
+	.request_ibi = dw_i3c_master_request_ibi,
+	.enable_ibi = dw_i3c_master_enable_ibi,
+	.free_ibi = dw_i3c_master_free_ibi,
+	.disable_ibi = dw_i3c_master_disable_ibi,
+	.recycle_ibi_slot = dw_i3c_master_recycle_ibi_slot,
+};
+
+/* hardware-specific ops */
+
+static int ast2600_i3c_pullup_to_reg(unsigned int ohms, u32 *regp)
+{
+	u32 reg;
+
+	switch (ohms) {
+	case 2000:
+		reg = AST2600_I3CG_REG0_SDA_PULLUP_EN_2K;
+		break;
+	case 750:
+		reg = AST2600_I3CG_REG0_SDA_PULLUP_EN_750;
+		break;
+	case 545:
+		reg = AST2600_I3CG_REG0_SDA_PULLUP_EN_2K |
+			AST2600_I3CG_REG0_SDA_PULLUP_EN_750;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (regp)
+		*regp = reg;
+
+	return 0;
+}
+
+static int ast2600_i3c_probe(struct dw_i3c_master *master,
+			     struct platform_device *pdev)
+{
+	struct pdata_ast2600 *pdata = &master->pdata.ast2600;
+	struct device_node *np = pdev->dev.of_node;
+	struct of_phandle_args gspec;
+	int rc;
+
+	rc = of_parse_phandle_with_fixed_args(np, "aspeed,global-regs", 1, 0,
+					      &gspec);
+	if (rc)
+		return -ENODEV;
+
+	pdata->global_regs = syscon_node_to_regmap(gspec.np);
+	of_node_put(gspec.np);
+
+	if (IS_ERR(pdata->global_regs))
+		return PTR_ERR(pdata->global_regs);
+
+	pdata->global_idx = gspec.args[0];
+
+	rc = of_property_read_u32(np, "sda-pullup-ohms", &pdata->sda_pullup);
+	if (rc)
+		pdata->sda_pullup = AST2600_DEFAULT_SDA_PULLUP_OHMS;
+
+	rc = ast2600_i3c_pullup_to_reg(pdata->sda_pullup, NULL);
+	if (rc)
+		dev_err(&master->base.dev, "invalid sda-pullup value %d\n",
+			pdata->sda_pullup);
+
+	return rc;
+}
+
+static int ast2600_i3c_init(struct dw_i3c_master *master)
+{
+	struct pdata_ast2600 *pdata = &master->pdata.ast2600;
+	u32 reg = 0;
+	int rc;
+
+	/* reg0: set SDA pullup values */
+	rc = ast2600_i3c_pullup_to_reg(pdata->sda_pullup, &reg);
+	if (rc)
+		return rc;
+
+	rc = regmap_write(pdata->global_regs,
+			  AST2600_I3CG_REG0(pdata->global_idx), reg);
+	if (rc)
+		return rc;
+
+	/* reg1: set up the instance id, but leave everything else disabled,
+	 * as it's all for client mode
+	 */
+	reg = AST2600_I3CG_REG1_INST_ID(pdata->global_idx);
+	rc = regmap_write(pdata->global_regs,
+			  AST2600_I3CG_REG1(pdata->global_idx), reg);
+
+	return rc;
+}
+
+static const struct dw_i3c_platform_ops ast2600_platform_ops = {
+	.probe = ast2600_i3c_probe,
+	.init = ast2600_i3c_init,
+	.toggle_scl_in = ast2600_i3c_toggle_scl_in,
+	.isolate_scl_sda = ast2600_i3c_isolate_scl_sda,
+	.gen_stop_to_internal = ast2600_i3c_gen_stop_to_internal,
+	.gen_tbits_in = ast2600_i3c_gen_tbits_in,
+};
+
+static const struct of_device_id dw_i3c_master_of_match[] = {
+	{ .compatible = "snps,dw-i3c-master-1.00a", },
+	{ .compatible = "aspeed,ast2600-i3c", .data = &ast2600_platform_ops },
+	{},
 };
+MODULE_DEVICE_TABLE(of, dw_i3c_master_of_match);
 
 static int dw_i3c_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *match;
 	struct dw_i3c_master *master;
 	int ret, irq;
+	int pos;
 
 	master = devm_kzalloc(&pdev->dev, sizeof(*master), GFP_KERNEL);
 	if (!master)
 		return -ENOMEM;
 
+	master->dev = &pdev->dev;
+	master->base.bus_driver_context = master;
+
 	master->regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(master->regs))
 		return PTR_ERR(master->regs);
@@ -1143,13 +2905,7 @@
 	spin_lock_init(&master->xferqueue.lock);
 	INIT_LIST_HEAD(&master->xferqueue.list);
 
-	writel(INTR_ALL, master->regs + INTR_STATUS);
-	irq = platform_get_irq(pdev, 0);
-	ret = devm_request_irq(&pdev->dev, irq,
-			       dw_i3c_master_irq_handler, 0,
-			       dev_name(&pdev->dev), master);
-	if (ret)
-		goto err_assert_rst;
+	spin_lock_init(&master->ibi.master.lock);
 
 	platform_set_drvdata(pdev, master);
 
@@ -1161,15 +2917,56 @@
 	master->caps.datafifodepth = DATA_BUFFER_STATUS_LEVEL_TX(ret);
 
 	ret = readl(master->regs + DEVICE_ADDR_TABLE_POINTER);
-	master->datstartaddr = ret;
-	master->maxdevs = ret >> 16;
+	master->datstartaddr = DEVICE_ADDR_TABLE_ADDR(ret);
+	master->maxdevs = DEVICE_ADDR_TABLE_DEPTH(ret);
+	master->dat_depth = DEVICE_ADDR_TABLE_DEPTH(ret);
+	if (master->maxdevs < MAX_DEVS) {
+		dev_info(master->dev, "HW DAT supports only %i target devices - enabling SW DAT to support %i devices\n",
+			 master->maxdevs, MAX_DEVS);
+		master->maxdevs = MAX_DEVS;
+		master->sw_dat_enabled = true;
+	}
 	master->free_pos = GENMASK(master->maxdevs - 1, 0);
 
-	ret = i3c_master_register(&master->base, &pdev->dev,
-				  &dw_mipi_i3c_ops, false);
+	/* Clear HW DAT */
+	for (pos = 0; pos < master->dat_depth; ++pos)
+		writel(0, master->regs + DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));
+
+	/* match any platform-specific ops */
+	match = of_match_node(dw_i3c_master_of_match, pdev->dev.of_node);
+	if (match && match->data)
+		master->platform_ops = match->data;
+
+	/* platform-specific probe */
+	if (master->platform_ops && master->platform_ops->probe) {
+		ret = master->platform_ops->probe(master, pdev);
+		if (ret)
+			goto err_assert_rst;
+	}
+
+	writel(INTR_ALL, master->regs + INTR_STATUS);
+	irq = platform_get_irq(pdev, 0);
+	ret = devm_request_irq(&pdev->dev, irq,
+			       dw_i3c_master_irq_handler, 0,
+			       dev_name(&pdev->dev), master);
+	if (ret)
+		goto err_assert_rst;
+
+	ret = readl(master->regs + I3C_VER_TYPE);
+	master->ver_type = I3C_VER_RELEASE_TYPE(ret);
+
+	dw_i3c_master_of_timings(master, pdev->dev.of_node);
+
+	master->base.pec_supported = true;
+
+	ret = i3c_register(&master->base, &pdev->dev, &dw_mipi_i3c_ops, &dw_mipi_i3c_target_ops,
+			   false);
 	if (ret)
 		goto err_assert_rst;
 
+	dev_info(&pdev->dev, "i3c bus %d registered, irq %d\n",
+		 master->base.bus_id, irq);
+
 	return 0;
 
 err_assert_rst:
@@ -1186,7 +2983,7 @@
 	struct dw_i3c_master *master = platform_get_drvdata(pdev);
 	int ret;
 
-	ret = i3c_master_unregister(&master->base);
+	ret = i3c_unregister(&master->base);
 	if (ret)
 		return ret;
 
@@ -1197,15 +2994,15 @@
 	return 0;
 }
 
-static const struct of_device_id dw_i3c_master_of_match[] = {
-	{ .compatible = "snps,dw-i3c-master-1.00a", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, dw_i3c_master_of_match);
+static void dw_i3c_shutdown(struct platform_device *pdev)
+{
+	dw_i3c_remove(pdev);
+}
 
 static struct platform_driver dw_i3c_driver = {
 	.probe = dw_i3c_probe,
 	.remove = dw_i3c_remove,
+	.shutdown = dw_i3c_shutdown,
 	.driver = {
 		.name = "dw-i3c-master",
 		.of_match_table = of_match_ptr(dw_i3c_master_of_match),
--- linux_org/drivers/i3c/master.c	2024-02-16 18:40:35.133696308 +0800
+++ linux/drivers/i3c/master.c	2024-02-16 18:40:22.241891438 +0800
@@ -103,12 +103,14 @@
 }
 
 static const struct device_type i3c_device_type;
+static const struct device_type i3c_target_device_type;
 
 static struct i3c_bus *dev_to_i3cbus(struct device *dev)
 {
 	struct i3c_master_controller *master;
 
-	if (dev->type == &i3c_device_type)
+	if (dev->type == &i3c_device_type ||
+	    dev->type == &i3c_target_device_type)
 		return dev_to_i3cdev(dev)->bus;
 
 	master = dev_to_i3cmaster(dev);
@@ -120,7 +122,8 @@
 {
 	struct i3c_master_controller *master;
 
-	if (dev->type == &i3c_device_type)
+	if (dev->type == &i3c_device_type ||
+	    dev->type == &i3c_target_device_type)
 		return dev_to_i3cdev(dev)->desc;
 
 	master = dev_to_i3cmaster(dev);
@@ -183,13 +186,19 @@
 				    struct device_attribute *da,
 				    char *buf)
 {
+	struct i3c_dev_desc *desc = dev_to_i3cdesc(dev);
+	struct i3c_master_controller *master = i3c_dev_get_master(desc);
 	struct i3c_bus *bus = dev_to_i3cbus(dev);
-	struct i3c_dev_desc *desc;
 	ssize_t ret;
+	u8 dyn_addr;
 
 	i3c_bus_normaluse_lock(bus);
-	desc = dev_to_i3cdesc(dev);
-	ret = sprintf(buf, "%02x\n", desc->info.dyn_addr);
+	if (master->target && master->target_ops->get_dyn_addr)
+		dyn_addr = master->target_ops->get_dyn_addr(master);
+	else
+		dyn_addr = desc->info.dyn_addr;
+
+	ret = sprintf(buf, "%02x\n", dyn_addr);
 	i3c_bus_normaluse_unlock(bus);
 
 	return ret;
@@ -316,7 +325,14 @@
 	.uevent = i3c_device_uevent,
 };
 
-const struct device_type i3c_target_device_type = {
+static struct attribute *i3c_target_device_attrs[] = {
+	&dev_attr_dynamic_address.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(i3c_target_device);
+
+static const struct device_type i3c_target_device_type = {
+	.groups = i3c_target_device_groups,
 };
 
 static int i3c_device_match(struct device *dev, struct device_driver *drv)
@@ -437,18 +453,20 @@
 					     I3C_ADDR_SLOT_RSVD);
 }
 
-static void i3c_bus_cleanup(struct i3c_bus *i3cbus)
+static void i3c_bus_cleanup(struct i3c_master_controller *master)
 {
 	mutex_lock(&i3c_core_lock);
-	idr_remove(&i3c_bus_idr, i3cbus->id);
+	idr_remove(&i3c_bus_idr, master->bus_id);
 	mutex_unlock(&i3c_core_lock);
 }
 
-static int i3c_bus_init(struct i3c_bus *i3cbus)
+static int i3c_bus_init(struct i3c_master_controller *master)
 {
+	struct i3c_bus *i3cbus = i3c_master_get_bus(master);
 	int ret;
 
 	init_rwsem(&i3cbus->lock);
+	mutex_init(&master->daa_lock);
 	INIT_LIST_HEAD(&i3cbus->devs.i2c);
 	INIT_LIST_HEAD(&i3cbus->devs.i3c);
 	i3c_bus_init_addrslots(i3cbus);
@@ -461,7 +479,7 @@
 	if (ret < 0)
 		return ret;
 
-	i3cbus->id = ret;
+	master->bus_id = ret;
 
 	return 0;
 }
@@ -473,6 +491,24 @@
 	[I3C_BUS_MODE_MIXED_SLOW] = "mixed-slow",
 };
 
+/**
+ * i3c_device_publish_event() - publish I3C framework event to all interested
+ *				devices
+ * @master: master used to handle devices
+ * @ev: I3C framework event to publish
+ */
+static void i3c_device_publish_event(struct i3c_master_controller *master,
+				     enum i3c_event ev)
+{
+	struct i3c_dev_desc *i3cdev;
+
+	i3c_bus_for_each_i3cdev(&master->bus, i3cdev) {
+		if (i3cdev->event_cb)
+			i3cdev->event_cb(i3cdev->dev, ev);
+	}
+}
+
+
 static ssize_t mode_show(struct device *dev,
 			 struct device_attribute *da,
 			 char *buf)
@@ -497,11 +533,12 @@
 				   struct device_attribute *da,
 				   char *buf)
 {
+	struct i3c_master_controller *master = dev_to_i3cmaster(dev);
 	struct i3c_bus *i3cbus = dev_to_i3cbus(dev);
 	ssize_t ret;
 
 	i3c_bus_normaluse_lock(i3cbus);
-	ret = sprintf(buf, "%d-%llx\n", i3cbus->id,
+	ret = sprintf(buf, "%d-%llx\n", master->bus_id,
 		      i3cbus->cur_master->info.pid);
 	i3c_bus_normaluse_unlock(i3cbus);
 
@@ -539,6 +576,47 @@
 }
 static DEVICE_ATTR_RO(i2c_scl_frequency);
 
+static ssize_t rescan_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct i3c_master_controller *master = dev_to_i3cmaster(dev);
+	struct i3c_bus *bus = i3c_master_get_bus(master);
+	bool res;
+	int ret;
+
+	ret = kstrtobool(buf, &res);
+	if (ret)
+		return ret;
+
+	if (!res)
+		return count;
+
+	i3c_device_publish_event(master, i3c_event_prepare_for_rescan);
+
+	i3c_bus_maintenance_lock(bus);
+
+	ret = i3c_master_rstdaa_locked(master, I3C_BROADCAST_ADDR);
+	if (ret && ret != I3C_ERROR_M2) {
+		dev_dbg(&master->dev,
+			"Failed to run RSTDAA for rescan, ret=%d\n", ret);
+		return ret;
+	}
+
+	i3c_bus_maintenance_unlock(bus);
+
+	ret = i3c_master_do_daa(master);
+	if (ret) {
+		dev_dbg(&master->dev, "Failed to run DAA for rescan, ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	i3c_device_publish_event(master, i3c_event_rescan_done);
+
+	return count;
+}
+static DEVICE_ATTR_WO(rescan);
+
 static struct attribute *i3c_masterdev_attrs[] = {
 	&dev_attr_mode.attr,
 	&dev_attr_current_master.attr,
@@ -549,7 +627,7 @@
 	&dev_attr_pid.attr,
 	&dev_attr_dynamic_address.attr,
 	&dev_attr_hdrcap.attr,
-	&dev_attr_bus_reset.attr,
+	&dev_attr_rescan.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(i3c_masterdev);
@@ -563,7 +641,7 @@
 		destroy_workqueue(master->wq);
 
 	WARN_ON(!list_empty(&bus->devs.i2c) || !list_empty(&bus->devs.i3c));
-	i3c_bus_cleanup(bus);
+	i3c_bus_cleanup(master);
 
 	of_node_put(dev->of_node);
 }
@@ -730,6 +808,27 @@
 }
 
 /**
+ * i3c_master_find_i3c_dev_by_addr() - find i3c_dev_desc basing on given address
+ * @master: I3C master object
+ * @addr: dynamic address to look a match with
+ *
+ * Return: the first i3c_dev_desc found with the given address; NULL if no device was found
+ */
+struct i3c_dev_desc *i3c_master_find_i3c_dev_by_addr(const struct i3c_master_controller *master,
+						     u16 addr)
+{
+	struct i3c_dev_desc *dev;
+
+	i3c_bus_for_each_i3cdev(&master->bus, dev) {
+		if (dev->info.dyn_addr == addr)
+			return dev;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(i3c_master_find_i3c_dev_by_addr);
+
+/**
  * i3c_master_get_free_addr() - get a free address on the bus
  * @master: I3C master object
  * @start_addr: where to start searching
@@ -1176,16 +1275,9 @@
 	if (!mrl)
 		return -ENOMEM;
 
-	/*
-	 * When the device does not have IBI payload SETMRL only sends 2
-	 * bytes of data.
-	 */
-	if (!(info->bcr & I3C_BCR_IBI_PAYLOAD))
-		dest.payload.len -= 1;
-
-	mrl->read_len = cpu_to_be16(read_len);
+	mrl->read_len = read_len;
 	mrl->ibi_len = ibi_len;
-	info->max_read_len = read_len;
+	info->max_read_len = be16_to_cpu(mrl->read_len);
 	info->max_ibi_len = mrl->ibi_len;
 	i3c_ccc_cmd_init(&cmd, false, I3C_CCC_SETMRL(false), &dest, 1, false,
 			 0);
@@ -1556,6 +1648,7 @@
 						      dev->info.dyn_addr);
 		if (status != I3C_ADDR_SLOT_FREE)
 			return -EBUSY;
+
 		i3c_bus_set_addr_slot_status(&master->bus,
 					     dev->info.dyn_addr,
 					     I3C_ADDR_SLOT_I3C_DEV);
@@ -1632,20 +1725,20 @@
 	if (ret)
 		goto err_free_dev;
 
-	/*
-	 * JESD403-1 devices only support SETAASA (will be called in do_daa)
-	 * Here we use SETDASA for non-JESD403-1 devices
-	 */
-	if (!I3C_DCR_IS_JESD403_COMPLIANT(i3cdev->boardinfo->dcr)) {
-		ret = i3c_master_setdasa_locked(
-			master, i3cdev->info.static_addr,
-			i3cdev->boardinfo->init_dyn_addr);
+	if (master->jdec_spd) {
+		i3cdev->info.dyn_addr = i3cdev->boardinfo->init_dyn_addr;
+		ret = i3c_master_reattach_i3c_dev(i3cdev,
+					i3cdev->info.static_addr);
+	} else {
+		ret = i3c_master_setdasa_locked(master,
+					i3cdev->info.static_addr,
+					i3cdev->boardinfo->init_dyn_addr);
 		if (ret)
 			goto err_detach_dev;
-	}
 
-	i3cdev->info.dyn_addr = i3cdev->boardinfo->init_dyn_addr;
-	ret = i3c_master_reattach_i3c_dev(i3cdev, 0);
+		i3cdev->info.dyn_addr = i3cdev->boardinfo->init_dyn_addr;
+		ret = i3c_master_reattach_i3c_dev(i3cdev, 0);
+	}
 	if (ret)
 		goto err_rstdaa;
 
@@ -1688,11 +1781,13 @@
 		desc->dev->dev.type = &i3c_device_type;
 		desc->dev->dev.bus = &i3c_bus_type;
 		desc->dev->dev.release = i3c_device_release;
-		dev_set_name(&desc->dev->dev, "%d-%llx", master->bus.id,
+		dev_set_name(&desc->dev->dev, "%d-%llx", master->bus_id,
 			     desc->info.pid);
 
-		if (desc->boardinfo)
+		if (desc->boardinfo) {
 			desc->dev->dev.of_node = desc->boardinfo->of_node;
+			desc->info.dcr = desc->boardinfo->dcr;
+		}
 
 		ret = device_register(&desc->dev->dev);
 		if (ret) {
@@ -1720,24 +1815,26 @@
  */
 int i3c_master_do_daa(struct i3c_master_controller *master)
 {
-	int ret;
+	int ret = 0;
 
+	mutex_lock(&master->daa_lock);
 	i3c_bus_maintenance_lock(&master->bus);
 	if (master->jdec_spd) {
-		i3c_master_sethid_locked(master);
-		i3c_master_setaasa_locked(master);
-	} else
+		ret = i3c_master_sethid_locked(master);
+		ret = i3c_master_setaasa_locked(master);
+	} else {
 		ret = master->ops->do_daa(master);
+	}
 	i3c_bus_maintenance_unlock(&master->bus);
 
 	if (ret)
-		return ret;
+		goto mutex_unlock;
 
-	i3c_bus_normaluse_lock(&master->bus);
 	i3c_master_register_new_i3c_devs(master);
-	i3c_bus_normaluse_unlock(&master->bus);
+mutex_unlock:
+	mutex_unlock(&master->daa_lock);
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(i3c_master_do_daa);
 
@@ -1797,6 +1894,10 @@
 	if (!i3c_bus_dev_addr_is_avail(&master->bus, info->dyn_addr))
 		return -EINVAL;
 
+	if (I3C_BCR_DEVICE_ROLE(info->bcr) == I3C_BCR_I3C_MASTER &&
+	    master->secondary)
+		return -EINVAL;
+
 	if (master->this)
 		return -EINVAL;
 
@@ -1805,10 +1906,7 @@
 		return PTR_ERR(i3cdev);
 
 	master->this = i3cdev;
-	if (master->secondary)
-		master->bus.cur_master = NULL;
-	else
-		master->bus.cur_master = master->this;
+	master->bus.cur_master = master->this;
 
 	ret = i3c_master_attach_i3c_dev(master, i3cdev);
 	if (ret)
@@ -1888,7 +1986,7 @@
 	struct i2c_dev_boardinfo *i2cboardinfo;
 	struct i3c_dev_boardinfo *i3cboardinfo;
 	struct i2c_dev_desc *i2cdev;
-	int ret;
+	int ret, n_i3cdev = 0;
 
 	/*
 	 * First attach all devices with static definitions provided by the
@@ -1940,8 +2038,12 @@
 		goto err_bus_cleanup;
 	}
 
-	if (master->secondary)
-		return 0;
+	/* Disable all slave events before starting DAA. */
+	ret = i3c_master_disec_locked(master, I3C_BROADCAST_ADDR,
+				      I3C_CCC_EVENT_SIR | I3C_CCC_EVENT_MR |
+				      I3C_CCC_EVENT_HJ);
+	if (ret && ret != I3C_ERROR_M2)
+		goto err_bus_cleanup;
 
 	/*
 	 * Reset all dynamic address that may have been assigned before
@@ -1951,13 +2053,6 @@
 	if (ret && ret != I3C_ERROR_M2)
 		goto err_bus_cleanup;
 
-	/* Disable all slave events before starting DAA. */
-	ret = i3c_master_disec_locked(master, I3C_BROADCAST_ADDR,
-				      I3C_CCC_EVENT_SIR | I3C_CCC_EVENT_MR |
-				      I3C_CCC_EVENT_HJ);
-	if (ret && ret != I3C_ERROR_M2)
-		goto err_bus_cleanup;
-
 	/*
 	 * Reserve init_dyn_addr first, and then try to pre-assign dynamic
 	 * address and retrieve device information if needed.
@@ -1966,7 +2061,6 @@
 	 * i3c_master_add_i3c_dev_locked().
 	 */
 	list_for_each_entry(i3cboardinfo, &master->boardinfo.i3c, node) {
-
 		/*
 		 * We don't reserve a dynamic address for devices that
 		 * don't explicitly request one.
@@ -1981,15 +2075,10 @@
 			goto err_rstdaa;
 		}
 
-		/*
-		 * If the static address equals to the assigned dynamic address,
-		 * don't reserve the address slot here, it will be set after the
-		 * DA has been assigned.
-		 */
 		if (i3cboardinfo->static_addr != i3cboardinfo->init_dyn_addr)
-			i3c_bus_set_addr_slot_status(
-				&master->bus, i3cboardinfo->init_dyn_addr,
-				I3C_ADDR_SLOT_I3C_DEV);
+			i3c_bus_set_addr_slot_status(&master->bus,
+						i3cboardinfo->init_dyn_addr,
+						I3C_ADDR_SLOT_I3C_DEV);
 
 		/*
 		 * Only try to create/attach devices that have a static
@@ -2001,20 +2090,20 @@
 
 		if (i3cboardinfo->static_addr)
 			i3c_master_early_i3c_dev_add(master, i3cboardinfo);
+
+		n_i3cdev++;
 	}
 
 	/*
-	 * Not support mix mode on JEDEC bus context. Here We only handle
-	 * the I2C part so simply return with success code.
+	 * Since SPD devices are all with static address.  Don't do DAA if we
+	 * know it is a pure I2C bus.
 	 */
-	if (master->jdec_spd && master->bus.mode != I3C_BUS_MODE_PURE)
+	if (master->jdec_spd && n_i3cdev == 0)
 		return 0;
 
 	ret = i3c_master_do_daa(master);
 	if (ret)
-		dev_dbg(&master->dev,
-			"Failed to do DAA: %d. However, devices with static address can still be accessed\n",
-			ret);
+		goto err_rstdaa;
 
 	return 0;
 
@@ -2033,6 +2122,25 @@
 
 static void i3c_master_bus_cleanup(struct i3c_master_controller *master)
 {
+	int ret;
+
+	i3c_bus_maintenance_lock(&master->bus);
+	/* Disable all slave events before starting DAA. */
+	ret = i3c_master_disec_locked(master, I3C_BROADCAST_ADDR,
+				      I3C_CCC_EVENT_SIR | I3C_CCC_EVENT_MR |
+				      I3C_CCC_EVENT_HJ);
+	if (ret && ret != I3C_ERROR_M2)
+		dev_dbg(&master->dev, "failed to send DISEC, ret=%i\n", ret);
+
+	/*
+	 * Reset all dynamic address that may have been assigned before
+	 * (assigned by the bootloader for example).
+	 */
+	ret = i3c_master_rstdaa_locked(master, I3C_BROADCAST_ADDR);
+	if (ret && ret != I3C_ERROR_M2)
+		dev_dbg(&master->dev, "failed to send RSTDAA, ret=%i\n", ret);
+	i3c_bus_maintenance_unlock(&master->bus);
+
 	if (master->ops->bus_cleanup)
 		master->ops->bus_cleanup(master);
 
@@ -2061,7 +2169,9 @@
 	struct i3c_dev_desc *i3cdev;
 
 	i3c_bus_for_each_i3cdev(&master->bus, i3cdev) {
-		if (i3cdev != refdev && i3cdev->info.pid == refdev->info.pid)
+		/* Skip the I3C dev representing this master. */
+		if (i3cdev != master->this && i3cdev != refdev &&
+		    i3cdev->info.pid == refdev->info.pid)
 			return i3cdev;
 	}
 
@@ -2088,10 +2198,8 @@
 				  u8 addr)
 {
 	struct i3c_device_info info = { .dyn_addr = addr };
-	struct i3c_dev_desc *newdev, *olddev;
+	struct i3c_dev_desc *newdev, *olddev, *tmpdev;
 	u8 old_dyn_addr = addr, expected_dyn_addr;
-	struct i3c_ibi_setup ibireq = { };
-	bool enable_ibi = false;
 	int ret;
 
 	if (!master)
@@ -2110,48 +2218,16 @@
 		goto err_detach_dev;
 
 	i3c_master_attach_boardinfo(newdev);
-
 	olddev = i3c_master_search_i3c_dev_duplicate(newdev);
 	if (olddev) {
-		newdev->dev = olddev->dev;
-		if (newdev->dev)
-			newdev->dev->desc = newdev;
-
-		/*
-		 * We need to restore the IBI state too, so let's save the
-		 * IBI information and try to restore them after olddev has
-		 * been detached+released and its IBI has been stopped and
-		 * the associated resources have been freed.
-		 */
-		mutex_lock(&olddev->ibi_lock);
-		if (olddev->ibi) {
-			ibireq.handler = olddev->ibi->handler;
-			ibireq.max_payload_len = olddev->ibi->max_payload_len;
-			ibireq.num_slots = olddev->ibi->num_slots;
-
-			if (olddev->ibi->enabled) {
-				enable_ibi = true;
-				i3c_dev_disable_ibi_locked(olddev);
-			}
-
-			i3c_dev_free_ibi_locked(olddev);
-		}
-		mutex_unlock(&olddev->ibi_lock);
-		if (olddev->info.max_ibi_len != newdev->info.max_ibi_len ||
-		    olddev->info.max_read_len != newdev->info.max_read_len)
-			i3c_master_setmrl_locked(master, &newdev->info,
-					      olddev->info.max_read_len,
-					      olddev->info.max_ibi_len);
-		if (olddev->info.max_write_len != newdev->info.max_write_len)
-			i3c_master_setmwl_locked(master, &newdev->info,
-					      olddev->info.max_write_len);
-		if (olddev->info.pec != newdev->info.pec)
-			i3c_device_control_pec(newdev->dev, olddev->info.pec);
-
 		old_dyn_addr = olddev->info.dyn_addr;
-
-		i3c_master_detach_i3c_dev(olddev);
-		i3c_master_free_i3c_dev(olddev);
+		tmpdev = olddev;
+		olddev = newdev;
+		newdev = tmpdev;
+	} else {
+		ret = i3c_master_reattach_i3c_dev(newdev, old_dyn_addr);
+		if (ret)
+			goto err_detach_dev;
 	}
 
 	/*
@@ -2164,54 +2240,35 @@
 	 * - in any other case, keep the address automatically assigned by the
 	 *   master
 	 */
-	if (old_dyn_addr && old_dyn_addr != newdev->info.dyn_addr)
+	if (old_dyn_addr && old_dyn_addr != addr)
 		expected_dyn_addr = old_dyn_addr;
 	else if (newdev->boardinfo && newdev->boardinfo->init_dyn_addr)
 		expected_dyn_addr = newdev->boardinfo->init_dyn_addr;
 	else
-		expected_dyn_addr = newdev->info.dyn_addr;
+		expected_dyn_addr = addr;
 
-	if (newdev->info.dyn_addr != expected_dyn_addr) {
+	if (addr != expected_dyn_addr) {
 		/*
 		 * Try to apply the expected dynamic address. If it fails, keep
 		 * the address assigned by the master.
 		 */
 		ret = i3c_master_setnewda_locked(master,
-						 newdev->info.dyn_addr,
+						 addr,
 						 expected_dyn_addr);
 		if (!ret) {
-			old_dyn_addr = newdev->info.dyn_addr;
+			old_dyn_addr = addr;
 			newdev->info.dyn_addr = expected_dyn_addr;
 			i3c_master_reattach_i3c_dev(newdev, old_dyn_addr);
 		} else {
 			dev_err(&master->dev,
 				"Failed to assign reserved/old address to device %d%llx",
-				master->bus.id, newdev->info.pid);
+				master->bus_id, newdev->info.pid);
 		}
 	}
 
-	/*
-	 * Now is time to try to restore the IBI setup. If we're lucky,
-	 * everything works as before, otherwise, all we can do is complain.
-	 * FIXME: maybe we should add callback to inform the driver that it
-	 * should request the IBI again instead of trying to hide that from
-	 * him.
-	 */
-	if (ibireq.handler) {
-		mutex_lock(&newdev->ibi_lock);
-		ret = i3c_dev_request_ibi_locked(newdev, &ibireq);
-		if (ret) {
-			dev_err(&master->dev,
-				"Failed to request IBI on device %d-%llx",
-				master->bus.id, newdev->info.pid);
-		} else if (enable_ibi) {
-			ret = i3c_dev_enable_ibi_locked(newdev);
-			if (ret)
-				dev_err(&master->dev,
-					"Failed to re-enable IBI on device %d-%llx",
-					master->bus.id, newdev->info.pid);
-		}
-		mutex_unlock(&newdev->ibi_lock);
+	if (olddev) {
+		i3c_master_detach_i3c_dev(olddev);
+		i3c_master_free_i3c_dev(olddev);
 	}
 
 	return 0;
@@ -2276,6 +2333,7 @@
 	u32 init_dyn_addr = 0;
 	u32 bcr = 0;
 	u32 dcr = 0;
+	int ret;
 
 	boardinfo = devm_kzalloc(dev, sizeof(*boardinfo), GFP_KERNEL);
 	if (!boardinfo)
@@ -2362,9 +2420,8 @@
 	if (!i3cbus_np)
 		return 0;
 
-	if (of_get_property(i3cbus_np, "jdec-spd", NULL)) {
+	if (of_get_property(i3cbus_np, "jdec-spd", NULL))
 		master->jdec_spd = 1;
-	}
 
 	/* For SPD bus, undo unnecessary address reservations. */
 	if (master->jdec_spd) {
@@ -2374,7 +2431,7 @@
 	}
 
 	for_each_available_child_of_node(i3cbus_np, node) {
-		if (node->name && of_node_cmp(node->name, "hub")) {
+		if (node->full_name && !strstr(node->full_name, "@0,0")) {
 			ret = of_i3c_master_add_dev(master, node);
 			if (ret) {
 				of_node_put(node);
@@ -2850,11 +2907,14 @@
 			bool secondary)
 {
 	unsigned long i2c_scl_rate = I3C_BUS_I2C_FM_PLUS_SCL_RATE;
-	struct i3c_bus *i3cbus = i3c_master_get_bus(master);
 	enum i3c_bus_mode mode = I3C_BUS_MODE_PURE;
 	struct i2c_dev_boardinfo *i2cbi;
+	struct i3c_bus *i3cbus;
 	int ret;
 
+	/* We do not support secondary masters yet. */
+	if (secondary)
+		return -ENOTSUPP;
 
 	ret = i3c_master_check_ops(ops);
 	if (ret)
@@ -2870,12 +2930,14 @@
 	INIT_LIST_HEAD(&master->boardinfo.i2c);
 	INIT_LIST_HEAD(&master->boardinfo.i3c);
 
-	ret = i3c_bus_init(i3cbus);
+	ret = i3c_bus_init(master);
 	if (ret)
 		return ret;
 
+	i3cbus = i3c_master_get_bus(master);
+
 	device_initialize(&master->dev);
-	dev_set_name(&master->dev, "i3c-%d", i3cbus->id);
+	dev_set_name(&master->dev, "i3c-%d", master->bus_id);
 
 	ret = of_populate_i3c_bus(master);
 	if (ret)
@@ -2935,18 +2997,7 @@
 	 * register I3C devices discovered during the initial DAA.
 	 */
 	master->init_done = true;
-	i3c_bus_normaluse_lock(&master->bus);
 	i3c_master_register_new_i3c_devs(master);
-#ifdef CONFIG_I3C_SLAVE_MQUEUE
-	if (master->secondary)
-		i3c_slave_mqueue_probe(master);
-#endif
-
-#ifdef CONFIG_I3C_SLAVE_EEPROM
-	if (master->secondary)
-		i3c_slave_eeprom_probe(master);
-#endif
-	i3c_bus_normaluse_unlock(&master->bus);
 
 	return 0;
 
@@ -2995,11 +3046,10 @@
 
 static void i3c_targetdev_release(struct device *dev)
 {
-	struct i3c_master_controller *master = container_of(dev, struct i3c_master_controller, dev);
-	struct i3c_bus *bus = &master->bus;
+	struct i3c_master_controller *master = dev_to_i3cmaster(dev);
 
 	mutex_lock(&i3c_core_lock);
-	idr_remove(&i3c_bus_idr, bus->id);
+	idr_remove(&i3c_bus_idr, master->bus_id);
 	mutex_unlock(&i3c_core_lock);
 
 	of_node_put(dev->of_node);
@@ -3038,7 +3088,7 @@
 	desc->dev->dev.release = i3c_target_device_release;
 	desc->info = info;
 	desc->common.master = master;
-	dev_set_name(&desc->dev->dev, "%d-target", master->bus.id);
+	dev_set_name(&desc->dev->dev, "%d-target", master->bus_id);
 
 	ret = device_register(&desc->dev->dev);
 	if (ret)
@@ -3108,10 +3158,10 @@
 	mutex_unlock(&i3c_core_lock);
 	if (ret < 0)
 		return ret;
-	i3cbus->id = ret;
+	master->bus_id = ret;
 
 	device_initialize(&master->dev);
-	dev_set_name(&master->dev, "i3c-%d", i3cbus->id);
+	dev_set_name(&master->dev, "i3c-%d", master->bus_id);
 
 	ret = device_add(&master->dev);
 	if (ret)
@@ -3278,6 +3328,27 @@
 	return master->target_ops->generate_ibi(dev, data, len);
 }
 
+int i3c_dev_put_read_data_locked(struct i3c_dev_desc *dev, struct i3c_priv_xfer *xfers,
+				 int nxfers, const u8 *ibi_data, int ibi_len)
+{
+	struct i3c_master_controller *master;
+
+	if (!dev)
+		return -ENOENT;
+
+	master = i3c_dev_get_master(dev);
+	if (!master)
+		return -EINVAL;
+
+	if (!master->target)
+		return -EINVAL;
+
+	if (!master->target_ops->put_read_data)
+		return -EOPNOTSUPP;
+
+	return master->target_ops->put_read_data(dev, xfers, nxfers, ibi_data, ibi_len);
+}
+
 int i3c_dev_disable_ibi_locked(struct i3c_dev_desc *dev)
 {
 	struct i3c_master_controller *master;
diff -Naur linux_org/drivers/i3c/mctp/i3c-mctp.c linux/drivers/i3c/mctp/i3c-mctp.c
--- linux_org/drivers/i3c/mctp/i3c-mctp.c	2024-02-06 01:18:16.459866416 +0800
+++ linux/drivers/i3c/mctp/i3c-mctp.c	2024-02-15 00:00:02.546932826 +0800
@@ -3,6 +3,8 @@
 
 #include <linux/cdev.h>
 #include <linux/fs.h>
+#include <linux/list.h>
+#include <linux/list_sort.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/poll.h>
@@ -17,6 +19,8 @@
 
 #include <linux/i3c/mctp/i3c-mctp.h>
 
+#include <uapi/linux/i3c/i3c-mctp.h>
+
 #define I3C_MCTP_MINORS				32
 #define CCC_DEVICE_STATUS_PENDING_INTR(x)	(((x) & GENMASK(3, 0)) >> 0)
 #define POLLING_TIMEOUT_MS			50
@@ -25,6 +29,13 @@
 #define I3C_MCTP_MIN_TRANSFER_SIZE		69
 #define I3C_MCTP_IBI_PAYLOAD_SIZE		2
 
+/* MCTP header definitions */
+#define MCTP_HDR_SRC_EID_OFFSET			2
+
+#define MAX_PROCESS_COUNT			255
+
+#define IS_BMC_NON_LEGACY(pid) (((pid) & 0xF) == 0xB)
+
 struct i3c_mctp {
 	struct i3c_device *i3c;
 	struct cdev cdev;
@@ -32,25 +43,41 @@
 	struct delayed_work polling_work;
 	struct platform_device *i3c_peci;
 	int id;
-	/*
-	 * Restrict an access to the /dev descriptor to one
-	 * user at a time.
-	 */
-	spinlock_t device_file_lock;
-	int device_open;
 	/* Currently only one userspace client is supported */
 	struct i3c_mctp_client *default_client;
 	struct i3c_mctp_client *peci_client;
 	u16 max_read_len;
 	u16 max_write_len;
+	struct list_head endpoints;
+	size_t endpoints_count;
+	/*
+	 * endpoints_lock protects list of endpoints
+	 */
+	struct mutex endpoints_lock;
+	spinlock_t clients_lock; /* to protect PECI and default client accesses */
+	u8 eid;
+	/*
+	 * As there can be more than one process opening the /dev file - we need
+	 * a counter to take care of device cleanup in case the file is opened
+	 * on device removal. We also need a locker to avoid potential race
+	 * conditions.
+	 */
+	spinlock_t file_lock;
+	u8 process_count;
 };
 
 struct i3c_mctp_client {
+	struct kref ref;
 	struct i3c_mctp *priv;
 	struct ptr_ring rx_queue;
 	wait_queue_head_t wait_queue;
 };
 
+struct i3c_mctp_endpoint {
+	struct i3c_mctp_eid_info eid_info;
+	struct list_head link;
+};
+
 static struct class *i3c_mctp_class;
 static dev_t i3c_mctp_devt;
 static DEFINE_IDA(i3c_mctp_ida);
@@ -84,13 +111,39 @@
 }
 EXPORT_SYMBOL_GPL(i3c_mctp_packet_free);
 
-static void i3c_mctp_client_free(struct i3c_mctp_client *client)
+/**
+ * i3c_mctp_flush_rx_queue() - flushes mctp client rx queue
+ *
+ * @client: pointer to the i3c mctp client whose rx queue should be flushed
+ */
+void i3c_mctp_flush_rx_queue(struct i3c_mctp_client *client)
+{
+	struct i3c_mctp_packet *packet;
+
+	while ((packet = ptr_ring_consume_bh(&client->rx_queue)))
+		i3c_mctp_packet_free(packet);
+}
+EXPORT_SYMBOL_GPL(i3c_mctp_flush_rx_queue);
+
+static void i3c_mctp_client_free(struct kref *ref)
 {
+	struct i3c_mctp_client *client = container_of(ref, typeof(*client), ref);
+
 	ptr_ring_cleanup(&client->rx_queue, &i3c_mctp_packet_free);
 
 	kfree(client);
 }
 
+static void i3c_mctp_client_get(struct i3c_mctp_client *client)
+{
+	kref_get(&client->ref);
+}
+
+static void i3c_mctp_client_put(struct i3c_mctp_client *client)
+{
+	kref_put(&client->ref, &i3c_mctp_client_free);
+}
+
 static struct i3c_mctp_client *i3c_mctp_client_alloc(struct i3c_mctp *priv)
 {
 	struct i3c_mctp_client *client;
@@ -98,15 +151,39 @@
 
 	client = kzalloc(sizeof(*client), GFP_KERNEL);
 	if (!client)
-		goto out;
+		return ERR_PTR(-ENOMEM);
 
+	kref_init(&client->ref);
 	client->priv = priv;
 	ret = ptr_ring_init(&client->rx_queue, RX_RING_COUNT, GFP_KERNEL);
 	if (ret)
-		return ERR_PTR(ret);
+		goto out;
+
 	init_waitqueue_head(&client->wait_queue);
-out:
+
 	return client;
+out:
+	i3c_mctp_client_put(client);
+	return ERR_PTR(ret);
+}
+
+static int i3c_mctp_register_default_client(struct i3c_mctp *priv, struct file *file)
+{
+	struct i3c_mctp_client *client;
+
+	if (priv->default_client)
+		return -EBUSY;
+
+	client = i3c_mctp_client_alloc(priv);
+	if (IS_ERR(client))
+		return PTR_ERR(client);
+
+	file->private_data = client;
+	spin_lock(&priv->clients_lock);
+	priv->default_client = client;
+	spin_unlock(&priv->clients_lock);
+
+	return 0;
 }
 
 static struct i3c_mctp_client *i3c_mctp_find_client(struct i3c_mctp *priv,
@@ -127,7 +204,7 @@
 
 static struct i3c_mctp_packet *i3c_mctp_read_packet(struct i3c_device *i3c)
 {
-	struct i3c_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3c));
+	struct i3c_mctp *priv = i3cdev_get_drvdata(i3c);
 	struct i3c_mctp_packet *rx_packet;
 	struct i3c_priv_xfer xfers = {
 		.rnw = true,
@@ -142,8 +219,7 @@
 	xfers.len = rx_packet->size;
 	xfers.data.in = &rx_packet->data;
 
-	/* Check against packet size + PEC byte to make sure that we always try to read max */
-	if (priv->max_read_len != xfers.len + 1) {
+	if (priv->max_read_len < xfers.len + 1) {
 		dev_dbg(i3cdev_to_dev(i3c), "Length mismatch. MRL = %d, xfers.len = %d",
 			priv->max_read_len, xfers.len);
 		i3c_mctp_packet_free(rx_packet);
@@ -155,6 +231,7 @@
 		i3c_mctp_packet_free(rx_packet);
 		return ERR_PTR(ret);
 	}
+
 	rx_packet->size = xfers.len;
 
 	return rx_packet;
@@ -162,14 +239,25 @@
 
 static void i3c_mctp_dispatch_packet(struct i3c_mctp *priv, struct i3c_mctp_packet *packet)
 {
-	struct i3c_mctp_client *client = i3c_mctp_find_client(priv, packet);
+	struct i3c_mctp_client *client;
 	int ret;
 
+	spin_lock(&priv->clients_lock);
+	client = i3c_mctp_find_client(priv, packet);
+	if (client)
+		i3c_mctp_client_get(client);
+	spin_unlock(&priv->clients_lock);
+
+	if (!client)
+		return;
+
 	ret = ptr_ring_produce(&client->rx_queue, packet);
 	if (ret)
 		i3c_mctp_packet_free(packet);
 	else
 		wake_up_all(&client->wait_queue);
+
+	i3c_mctp_client_put(client);
 }
 
 static void i3c_mctp_polling_work(struct work_struct *work)
@@ -197,45 +285,75 @@
 	schedule_delayed_work(&priv->polling_work, msecs_to_jiffies(POLLING_TIMEOUT_MS));
 }
 
+static int i3c_mctp_open(struct inode *inode, struct file *file)
+{
+	struct i3c_mctp *priv = container_of(inode->i_cdev, struct i3c_mctp, cdev);
+	int ret = 0;
+
+	spin_lock(&priv->file_lock);
+	if (priv->process_count >= MAX_PROCESS_COUNT) {
+		ret = -EBUSY;
+		goto out_unlock;
+	}
+
+	priv->process_count++;
+
+out_unlock:
+	spin_unlock(&priv->file_lock);
+
+	return ret;
+}
+
 static ssize_t i3c_mctp_write(struct file *file, const char __user *buf, size_t count,
 			      loff_t *f_pos)
 {
-	struct i3c_mctp *priv = file->private_data;
-	struct i3c_device *i3c = priv->i3c;
-	struct i3c_priv_xfer xfers = {
-		.rnw = false,
-		.len = count,
-	};
-	u8 *data;
+	struct i3c_mctp_client *client = file->private_data;
+	struct i3c_mctp_packet *tx_packet;
 	int ret;
 
-	/*
-	 * Check against packet size + PEC byte
-	 * to not send more data than it was set in the probe
-	 */
-	if (priv->max_write_len < xfers.len + 1) {
-		dev_dbg(i3cdev_to_dev(i3c), "Length mismatch. MWL = %d, xfers.len = %d",
-			priv->max_write_len, xfers.len);
+	if (!client || !client->priv)
+		return -EBADF;
+
+	if (count < I3C_MCTP_MIN_PACKET_SIZE)
 		return -EINVAL;
+
+	if (count > sizeof(tx_packet->data))
+		return -ENOSPC;
+
+	tx_packet = i3c_mctp_packet_alloc(GFP_KERNEL);
+	if (!tx_packet)
+		return -ENOMEM;
+
+	if (copy_from_user(&tx_packet->data, buf, count)) {
+		dev_err(client->priv->dev, "copy from user failed\n");
+		ret = -EFAULT;
+		goto out_packet;
 	}
 
-	data = memdup_user(buf, count);
-	if (IS_ERR(data))
-		return PTR_ERR(data);
+	tx_packet->size = count;
+
+	ret = i3c_mctp_send_packet(client->priv->i3c, tx_packet);
+	if (ret)
+		goto out_packet;
 
-	xfers.data.out = data;
+	ret = count;
 
-	ret = i3c_device_do_priv_xfers(i3c, &xfers, 1);
-	kfree(data);
-	return ret ?: count;
+out_packet:
+	i3c_mctp_packet_free(tx_packet);
+	return ret;
 }
 
 static ssize_t i3c_mctp_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
 {
-	struct i3c_mctp *priv = file->private_data;
-	struct i3c_mctp_client *client = priv->default_client;
+	struct i3c_mctp_client *client = file->private_data;
 	struct i3c_mctp_packet *rx_packet;
 
+	if (!client)
+		return -EBADF;
+
+	if (count < I3C_MCTP_MIN_PACKET_SIZE)
+		return -EINVAL;
+
 	if (count > sizeof(rx_packet->data))
 		count = sizeof(rx_packet->data);
 
@@ -247,37 +365,36 @@
 		count = rx_packet->size;
 
 	if (copy_to_user(buf, &rx_packet->data, count))
-		return -EFAULT;
+		count = -EFAULT;
 
 	i3c_mctp_packet_free(rx_packet);
 
 	return count;
 }
 
-static int i3c_mctp_open(struct inode *inode, struct file *file)
+static int i3c_mctp_release(struct inode *inode, struct file *file)
 {
 	struct i3c_mctp *priv = container_of(inode->i_cdev, struct i3c_mctp, cdev);
+	struct i3c_mctp_client *client = file->private_data;
 
-	spin_lock(&priv->device_file_lock);
-	if (priv->device_open) {
-		spin_unlock(&priv->device_file_lock);
-		return -EBUSY;
+	if (inode->i_cdev && priv) {
+		spin_lock(&priv->file_lock);
+		priv->process_count--;
+		spin_unlock(&priv->file_lock);
 	}
-	priv->device_open++;
-	spin_unlock(&priv->device_file_lock);
 
-	file->private_data = priv;
+	if (!client)
+		return 0;
 
-	return 0;
-}
+	if (!client->priv)
+		goto out;
 
-static int i3c_mctp_release(struct inode *inode, struct file *file)
-{
-	struct i3c_mctp *priv = file->private_data;
+	spin_lock(&client->priv->clients_lock);
+	client->priv->default_client = NULL;
+	spin_unlock(&client->priv->clients_lock);
 
-	spin_lock(&priv->device_file_lock);
-	priv->device_open--;
-	spin_unlock(&priv->device_file_lock);
+out:
+	i3c_mctp_client_put(client);
 
 	file->private_data = NULL;
 
@@ -286,24 +403,177 @@
 
 static __poll_t i3c_mctp_poll(struct file *file, struct poll_table_struct *pt)
 {
-	struct i3c_mctp *priv = file->private_data;
+	struct i3c_mctp_client *client = file->private_data;
 	__poll_t ret = 0;
 
-	poll_wait(file, &priv->default_client->wait_queue, pt);
+	if (!client)
+		return ret;
+
+	poll_wait(file, &client->wait_queue, pt);
 
-	if (__ptr_ring_peek(&priv->default_client->rx_queue))
+	if (__ptr_ring_peek(&client->rx_queue))
 		ret |= EPOLLIN;
 
 	return ret;
 }
 
+static int
+eid_info_cmp(void *priv, struct list_head *a, struct list_head *b)
+{
+	struct i3c_mctp_endpoint *endpoint_a;
+	struct i3c_mctp_endpoint *endpoint_b;
+
+	if (a == b)
+		return 0;
+
+	endpoint_a = list_entry(a, typeof(*endpoint_a), link);
+	endpoint_b = list_entry(b, typeof(*endpoint_b), link);
+
+	if (endpoint_a->eid_info.eid < endpoint_b->eid_info.eid)
+		return -1;
+	else if (endpoint_a->eid_info.eid > endpoint_b->eid_info.eid)
+		return 1;
+
+	return 0;
+}
+
+static void i3c_mctp_eid_info_list_remove(struct list_head *list)
+{
+	struct i3c_mctp_endpoint *endpoint;
+	struct i3c_mctp_endpoint *tmp;
+
+	list_for_each_entry_safe(endpoint, tmp, list, link) {
+		list_del(&endpoint->link);
+		kfree(endpoint);
+	}
+}
+
+static bool
+i3c_mctp_eid_info_list_valid(struct list_head *list)
+{
+	struct i3c_mctp_endpoint *endpoint;
+	struct i3c_mctp_endpoint *next;
+
+	list_for_each_entry(endpoint, list, link) {
+		next = list_next_entry(endpoint, link);
+		if (&next->link == list)
+			break;
+
+		/* duplicated eids */
+		if (next->eid_info.eid == endpoint->eid_info.eid)
+			return false;
+	}
+
+	return true;
+}
+
+static int
+i3c_mctp_set_eid_info(struct i3c_mctp *priv, struct i3c_mctp_set_eid_info __user *userbuf)
+{
+	struct list_head list = LIST_HEAD_INIT(list);
+	struct i3c_mctp_set_eid_info set_eid;
+	struct i3c_mctp_endpoint *endpoint;
+	void *user_ptr;
+	int ret = 0;
+	size_t i;
+
+	if (copy_from_user(&set_eid, userbuf, sizeof(set_eid))) {
+		dev_err(priv->dev, "copy from user failed\n");
+		return -EFAULT;
+	}
+
+	if (set_eid.count > I3C_MCTP_EID_INFO_MAX)
+		return -EINVAL;
+
+	user_ptr = u64_to_user_ptr(set_eid.ptr);
+	for (i = 0; i < set_eid.count; i++) {
+		endpoint = kzalloc(sizeof(*endpoint), GFP_KERNEL);
+		if (!endpoint) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		memset(endpoint, 0, sizeof(*endpoint));
+
+		ret = copy_from_user(&endpoint->eid_info,
+				     &(((struct i3c_mctp_eid_info *)user_ptr)[i]),
+				     sizeof(struct i3c_mctp_eid_info));
+
+		if (ret) {
+			dev_err(priv->dev, "copy from user failed\n");
+			kfree(endpoint);
+			ret = -EFAULT;
+			goto out;
+		}
+
+		list_add_tail(&endpoint->link, &list);
+	}
+
+	list_sort(NULL, &list, eid_info_cmp);
+	if (!i3c_mctp_eid_info_list_valid(&list)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	mutex_lock(&priv->endpoints_lock);
+	if (list_empty(&priv->endpoints))
+		list_splice_init(&list, &priv->endpoints);
+	else
+		list_swap(&list, &priv->endpoints);
+	priv->endpoints_count = set_eid.count;
+	mutex_unlock(&priv->endpoints_lock);
+out:
+	i3c_mctp_eid_info_list_remove(&list);
+	return ret;
+}
+
+static int i3c_mctp_set_own_eid(struct i3c_mctp *priv, void __user *userbuf)
+{
+	struct i3c_mctp_set_own_eid data;
+
+	if (copy_from_user(&data, userbuf, sizeof(data))) {
+		dev_err(priv->dev, "copy from user failed\n");
+		return -EFAULT;
+	}
+
+	priv->eid = data.eid;
+
+	return 0;
+}
+
+static long
+i3c_mctp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct i3c_mctp *priv = container_of(file_inode(file)->i_cdev, struct i3c_mctp, cdev);
+	void __user *userbuf = (void __user *)arg;
+	int ret;
+
+	if (!file_inode(file)->i_cdev)
+		return -ENODEV;
+
+	switch (cmd) {
+	case I3C_MCTP_IOCTL_SET_EID_INFO:
+		ret = i3c_mctp_set_eid_info(priv, userbuf);
+		break;
+	case I3C_MCTP_IOCTL_SET_OWN_EID:
+		ret = i3c_mctp_set_own_eid(priv, userbuf);
+		break;
+	case I3C_MCTP_IOCTL_REGISTER_DEFAULT_CLIENT:
+		ret = i3c_mctp_register_default_client(priv, file);
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
 static const struct file_operations i3c_mctp_fops = {
 	.owner = THIS_MODULE,
+	.open = i3c_mctp_open,
 	.read = i3c_mctp_read,
 	.write = i3c_mctp_write,
 	.poll = i3c_mctp_poll,
-	.open = i3c_mctp_open,
 	.release = i3c_mctp_release,
+	.unlocked_ioctl = i3c_mctp_ioctl,
 };
 
 /**
@@ -314,14 +584,16 @@
  */
 struct i3c_mctp_client *i3c_mctp_add_peci_client(struct i3c_device *i3c)
 {
-	struct i3c_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3c));
+	struct i3c_mctp *priv = i3cdev_get_drvdata(i3c);
 	struct i3c_mctp_client *client;
 
 	client = i3c_mctp_client_alloc(priv);
 	if (IS_ERR(client))
-		return ERR_PTR(-ENOMEM);
+		return client;
 
+	spin_lock(&priv->clients_lock);
 	priv->peci_client = client;
+	spin_unlock(&priv->clients_lock);
 
 	return priv->peci_client;
 }
@@ -335,9 +607,11 @@
 {
 	struct i3c_mctp *priv = client->priv;
 
-	i3c_mctp_client_free(priv->peci_client);
-
+	spin_lock(&priv->clients_lock);
 	priv->peci_client = NULL;
+	spin_unlock(&priv->clients_lock);
+
+	i3c_mctp_client_put(client);
 }
 EXPORT_SYMBOL_GPL(i3c_mctp_remove_peci_client);
 
@@ -358,15 +632,21 @@
 
 	priv->id = id;
 	priv->i3c = i3c;
+	priv->eid = 0;
+	priv->process_count = 0;
 
-	spin_lock_init(&priv->device_file_lock);
+	INIT_LIST_HEAD(&priv->endpoints);
+	mutex_init(&priv->endpoints_lock);
+
+	spin_lock_init(&priv->clients_lock);
+	spin_lock_init(&priv->file_lock);
 
 	return priv;
 }
 
 static void i3c_mctp_ibi_handler(struct i3c_device *dev, const struct i3c_ibi_payload *payload)
 {
-	struct i3c_mctp *priv = dev_get_drvdata(i3cdev_to_dev(dev));
+	struct i3c_mctp *priv = i3cdev_get_drvdata(dev);
 	struct i3c_mctp_packet *rx_packet;
 
 	rx_packet = i3c_mctp_read_packet(dev);
@@ -438,6 +718,12 @@
 	return ret;
 }
 
+static void i3c_mctp_disable_ibi(struct i3c_device *i3cdev)
+{
+	i3c_device_disable_ibi(i3cdev);
+	i3c_device_free_ibi(i3cdev);
+}
+
 /**
  * i3c_mctp_get_eid() - receive MCTP EID assigned to the device
  *
@@ -450,9 +736,25 @@
  */
 int i3c_mctp_get_eid(struct i3c_mctp_client *client, u8 domain_id, u8 *eid)
 {
-	/* TODO: Implement EID assignment basing on domain ID */
-	*eid = 1;
-	return 0;
+	struct i3c_mctp_endpoint *endpoint;
+	struct i3c_device_info info;
+	int ret = -ENOENT;
+
+	i3c_device_get_info(client->priv->i3c, &info);
+
+	mutex_lock(&client->priv->endpoints_lock);
+
+	list_for_each_entry(endpoint, &client->priv->endpoints, link) {
+		if (endpoint->eid_info.domain_id == domain_id &&
+		    endpoint->eid_info.dyn_addr == info.dyn_addr) {
+			*eid = endpoint->eid_info.eid;
+			ret = 0;
+			break;
+		}
+	}
+
+	mutex_unlock(&client->priv->endpoints_lock);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(i3c_mctp_get_eid);
 
@@ -466,12 +768,29 @@
  */
 int i3c_mctp_send_packet(struct i3c_device *i3c, struct i3c_mctp_packet *tx_packet)
 {
+	struct i3c_mctp *priv = i3cdev_get_drvdata(i3c);
+	u8 *protocol_hdr = (u8 *)tx_packet->data.protocol_hdr;
 	struct i3c_priv_xfer xfers = {
 		.rnw = false,
 		.len = tx_packet->size,
 		.data.out = &tx_packet->data,
 	};
 
+	/*
+	 * Check against packet size + PEC byte
+	 * to not send more data than it was set in the probe
+	 */
+	if (priv->max_write_len < xfers.len + 1) {
+		dev_dbg(i3cdev_to_dev(i3c), "Length mismatch. MWL = %d, xfers.len = %d",
+			priv->max_write_len, xfers.len);
+		return -EINVAL;
+	}
+
+	spin_lock(&priv->clients_lock);
+	if (i3c_mctp_find_client(priv, tx_packet) == priv->peci_client)
+		protocol_hdr[MCTP_HDR_SRC_EID_OFFSET] = priv->eid;
+	spin_unlock(&priv->clients_lock);
+
 	return i3c_device_do_priv_xfers(i3c, &xfers, 1);
 }
 EXPORT_SYMBOL_GPL(i3c_mctp_send_packet);
@@ -508,9 +827,35 @@
 }
 EXPORT_SYMBOL_GPL(i3c_mctp_receive_packet);
 
+static void i3c_mctp_i3c_event_cb(struct i3c_device *dev, enum i3c_event event)
+{
+	struct i3c_mctp *priv = i3cdev_get_drvdata(dev);
+	struct i3c_device_info info;
+
+	switch (event) {
+	case i3c_event_prepare_for_rescan:
+		/*
+		 * Disable IBI and polling mode blindly.
+		 */
+		i3c_device_disable_ibi(dev);
+		cancel_delayed_work(&priv->polling_work);
+		break;
+	case i3c_event_rescan_done:
+		i3c_device_get_info(dev, &info);
+		if (IS_BMC_NON_LEGACY(info.pid) || i3c_device_enable_ibi(dev)) {
+			INIT_DELAYED_WORK(&priv->polling_work,
+					  i3c_mctp_polling_work);
+			schedule_delayed_work(&priv->polling_work,
+					      msecs_to_jiffies(POLLING_TIMEOUT_MS));
+		}
+		break;
+	default:
+		break;
+	}
+}
+
 static int i3c_mctp_probe(struct i3c_device *i3cdev)
 {
-	int ibi_payload_size = I3C_MCTP_IBI_PAYLOAD_SIZE;
 	struct device *dev = i3cdev_to_dev(i3cdev);
 	struct i3c_device_info info;
 	struct i3c_mctp *priv;
@@ -536,54 +881,48 @@
 		goto error;
 	}
 
-	ret = i3c_device_control_pec(i3cdev, false);
+	ret = i3c_device_control_pec(i3cdev, true);
 	if (ret)
 		goto error;
 
-	priv->default_client = i3c_mctp_client_alloc(priv);
-	if (IS_ERR(priv->default_client))
-		goto error;
-
-	dev_set_drvdata(i3cdev_to_dev(i3cdev), priv);
+	i3cdev_set_drvdata(i3cdev, priv);
 
 	priv->i3c_peci = platform_device_register_data(i3cdev_to_dev(i3cdev), "peci-i3c", priv->id,
 						       NULL, 0);
 	if (IS_ERR(priv->i3c_peci))
 		dev_warn(priv->dev, "failed to register peci-i3c device\n");
 
-	if (i3c_mctp_enable_ibi(i3cdev)) {
-		INIT_DELAYED_WORK(&priv->polling_work, i3c_mctp_polling_work);
-		schedule_delayed_work(&priv->polling_work, msecs_to_jiffies(POLLING_TIMEOUT_MS));
-		ibi_payload_size = 0;
-	}
-
 	i3c_device_get_info(i3cdev, &info);
 
 	ret = i3c_device_getmrl_ccc(i3cdev, &info);
-	if (ret || info.max_read_len != I3C_MCTP_MIN_TRANSFER_SIZE)
-		ret = i3c_device_setmrl_ccc(i3cdev, &info, I3C_MCTP_MIN_TRANSFER_SIZE,
-					    ibi_payload_size);
-	if (ret && info.max_read_len != I3C_MCTP_MIN_TRANSFER_SIZE) {
-		dev_err(dev, "Failed to set MRL!, ret = %d\n", ret);
-		goto error_peci;
+	if (ret || info.max_read_len < I3C_MCTP_MIN_TRANSFER_SIZE)
+		ret = i3c_device_setmrl_ccc(i3cdev, &info, cpu_to_be16(I3C_MCTP_MIN_TRANSFER_SIZE),
+					    I3C_MCTP_IBI_PAYLOAD_SIZE);
+	if (ret && info.max_read_len < I3C_MCTP_MIN_TRANSFER_SIZE) {
+		dev_info(dev, "Failed to set MRL, ret = %d, running with default: %d\n", ret,
+			 I3C_MCTP_MIN_TRANSFER_SIZE);
+		info.max_read_len = I3C_MCTP_MIN_TRANSFER_SIZE;
 	}
 	priv->max_read_len = info.max_read_len;
 
 	ret = i3c_device_getmwl_ccc(i3cdev, &info);
-	if (ret || info.max_write_len != I3C_MCTP_MIN_TRANSFER_SIZE)
-		ret = i3c_device_setmwl_ccc(i3cdev, &info, I3C_MCTP_MIN_TRANSFER_SIZE);
-	if (ret && info.max_write_len != I3C_MCTP_MIN_TRANSFER_SIZE) {
-		dev_err(dev, "Failed to set MWL!, ret = %d\n", ret);
-		goto error_peci;
+	if (ret || info.max_write_len < I3C_MCTP_MIN_TRANSFER_SIZE)
+		ret = i3c_device_setmwl_ccc(i3cdev, &info, cpu_to_be16(I3C_MCTP_MIN_TRANSFER_SIZE));
+	if (ret && info.max_write_len < I3C_MCTP_MIN_TRANSFER_SIZE) {
+		dev_info(dev, "Failed to set MWL, ret = %d, running with default: %d\n", ret,
+			 I3C_MCTP_MIN_TRANSFER_SIZE);
+		info.max_write_len = I3C_MCTP_MIN_TRANSFER_SIZE;
 	}
 	priv->max_write_len = info.max_write_len;
 
+	i3c_device_register_event_cb(i3cdev, i3c_mctp_i3c_event_cb);
+	if (IS_BMC_NON_LEGACY(info.pid) || i3c_mctp_enable_ibi(i3cdev)) {
+		INIT_DELAYED_WORK(&priv->polling_work, i3c_mctp_polling_work);
+		schedule_delayed_work(&priv->polling_work, msecs_to_jiffies(POLLING_TIMEOUT_MS));
+	}
+
 	return 0;
 
-error_peci:
-	platform_device_unregister(priv->i3c_peci);
-	i3c_device_disable_ibi(i3cdev);
-	i3c_device_free_ibi(i3cdev);
 error:
 	cdev_del(&priv->cdev);
 error_cdev:
@@ -593,26 +932,33 @@
 
 static void i3c_mctp_remove(struct i3c_device *i3cdev)
 {
-	struct i3c_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3cdev));
+	struct i3c_mctp *priv = i3cdev_get_drvdata(i3cdev);
+	int i;
 
-	i3c_device_disable_ibi(i3cdev);
-	i3c_device_free_ibi(i3cdev);
-	i3c_mctp_client_free(priv->default_client);
-	priv->default_client = NULL;
+	if (priv->default_client)
+		priv->default_client->priv = NULL;
+
+	spin_lock(&priv->file_lock);
+	for (i = 0; i < priv->process_count; i++) {
+		kobject_put(&priv->cdev.kobj);
+		module_put(priv->cdev.owner);
+	}
+	spin_unlock(&priv->file_lock);
+
+	i3c_mctp_disable_ibi(i3cdev);
+	cancel_delayed_work(&priv->polling_work);
 	platform_device_unregister(priv->i3c_peci);
 
 	device_destroy(i3c_mctp_class, MKDEV(MAJOR(i3c_mctp_devt), priv->id));
 	cdev_del(&priv->cdev);
+	i3c_mctp_eid_info_list_remove(&priv->endpoints);
 	ida_free(&i3c_mctp_ida, priv->id);
 }
 
 static const struct i3c_device_id i3c_mctp_ids[] = {
 	I3C_CLASS(0xCC, 0x0),
-	I3C_DEVICE(0x3f6, 0x0503, (void *)0),
-	I3C_DEVICE(0x3f6, 0x8000, (void *)0),
-	I3C_DEVICE(0x3f6, 0x8001, (void *)0),
-	I3C_DEVICE(0x3f6, 0xA001, (void *)0),
-	I3C_DEVICE(0x3f6, 0xA003, (void *)0),
+	/* Workaround for GNR A0 where I3C MNG IP introduces itself with DCR=0xC9 */
+	I3C_CLASS(0xC9, 0x0),
 	{ },
 };
 
diff -Naur linux_org/drivers/i3c/mctp/i3c-target-mctp.c linux/drivers/i3c/mctp/i3c-target-mctp.c
--- linux_org/drivers/i3c/mctp/i3c-target-mctp.c	2024-02-06 01:18:16.247869524 +0800
+++ linux/drivers/i3c/mctp/i3c-target-mctp.c	2024-02-15 00:00:02.546932826 +0800
@@ -2,6 +2,7 @@
 /* Copyright (C) 2022 Intel Corporation.*/
 
 #include <linux/cdev.h>
+#include <linux/i2c.h>
 #include <linux/idr.h>
 #include <linux/module.h>
 #include <linux/poll.h>
@@ -9,10 +10,17 @@
 #include <linux/workqueue.h>
 
 #include <linux/i3c/device.h>
+#include <linux/i3c/master.h>
+
+#include <linux/i3c/mctp/i3c-mctp.h>
 
 #define I3C_TARGET_MCTP_MINORS	32
 #define RX_RING_COUNT		16
 
+#define I3C_TARGET_IBI_PLD_SIZE	2
+
+#define I3C_TARGET_MCTP_MDB	0xAE
+
 static struct class *i3c_target_mctp_class;
 static dev_t i3c_target_mctp_devt;
 static DEFINE_IDA(i3c_target_mctp_ida);
@@ -25,6 +33,7 @@
 	int id;
 	struct mctp_client *client;
 	spinlock_t client_lock; /* to protect client access */
+	struct device *dev;
 };
 
 struct mctp_client {
@@ -39,6 +48,18 @@
 	u16 count;
 };
 
+static u8 i3c_pec_calculate(u8 addr, const u8 *data, size_t count)
+{
+	u8 pec;
+
+	/*
+	 * MCTP over I3C PEC calulcaton is done with same algorithm SMBus PEC does.
+	 * Target device address (with RnW bit) is also included to PEC calculation.
+	 */
+	pec = i2c_smbus_pec(0x00, &addr, sizeof(addr));
+	return i2c_smbus_pec(pec, (u8 *)data, count);
+}
+
 static void *i3c_target_mctp_packet_alloc(u16 count)
 {
 	struct mctp_packet *packet;
@@ -105,10 +126,26 @@
 static void
 i3c_target_mctp_rx_packet_enqueue(struct i3c_device *i3cdev, const u8 *data, size_t count)
 {
-	struct i3c_target_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3cdev));
+	struct i3c_target_mctp *priv = i3cdev_get_drvdata(i3cdev);
 	struct mctp_client *client;
 	struct mctp_packet *packet;
+	size_t len;
 	int ret;
+	u8 addr;
+	u8 pec;
+
+	/* One byte for PEC */
+	if (count < (I3C_MCTP_MIN_PACKET_SIZE + 1) || count > (I3C_MCTP_PACKET_SIZE + 1))
+		return;
+
+	len = count - 1; /* PEC is the last byte */
+
+	addr = i3cdev->desc->info.dyn_addr << 1;
+	pec = i3c_pec_calculate(addr, data, len);
+	if (pec != data[count - 1]) {
+		dev_warn(i3cdev_to_dev(i3cdev), "PEC verification failed for incoming message\n");
+		return;
+	}
 
 	spin_lock(&priv->client_lock);
 	client = priv->client;
@@ -119,11 +156,11 @@
 	if (!client)
 		return;
 
-	packet = i3c_target_mctp_packet_alloc(count);
+	packet = i3c_target_mctp_packet_alloc(len);
 	if (!packet)
 		goto err;
 
-	memcpy(packet->data, data, count);
+	memcpy(packet->data, data, len);
 
 	ret = ptr_ring_produce(&client->rx_queue, packet);
 	if (ret)
@@ -164,10 +201,14 @@
 {
 	struct i3c_target_mctp *priv = client->priv;
 
+	if (!priv)
+		goto out;
+
 	spin_lock_irq(&priv->client_lock);
 	priv->client = NULL;
 	spin_unlock_irq(&priv->client_lock);
 
+out:
 	i3c_target_mctp_client_put(client);
 }
 
@@ -222,13 +263,25 @@
 static ssize_t i3c_target_mctp_write(struct file *file, const char __user *buf,
 				     size_t count, loff_t *ppos)
 {
+	const size_t total_count = count + 1; /* One extra byte for PEC */
 	struct mctp_client *client = file->private_data;
 	struct i3c_target_mctp *priv = client->priv;
 	struct i3c_priv_xfer xfers[1] = {};
 	u8 *tx_data;
+	u8 ibi_payload[I3C_TARGET_IBI_PLD_SIZE] = {I3C_TARGET_MCTP_MDB, 0xAE};
 	int ret;
+	u8 addr;
+
+	if (!priv)
+		return -ENODEV;
+
+	if (count < I3C_MCTP_MIN_PACKET_SIZE)
+		return -EINVAL;
 
-	tx_data = kzalloc(count, GFP_KERNEL);
+	if (count > I3C_MCTP_PACKET_SIZE)
+		return -ENOSPC;
+
+	tx_data = kzalloc(total_count, GFP_KERNEL);
 	if (!tx_data)
 		return -ENOMEM;
 
@@ -237,21 +290,18 @@
 		goto out_packet;
 	}
 
+	addr = (priv->i3cdev->desc->info.dyn_addr << 1) | 0x01;
+	tx_data[total_count - 1] = i3c_pec_calculate(addr, tx_data, count);
+
 	xfers[0].data.out = tx_data;
-	xfers[0].len = count;
+	xfers[0].len = total_count;
 
-	ret = i3c_device_do_priv_xfers(priv->i3cdev, xfers, ARRAY_SIZE(xfers));
+	ret = i3c_device_put_read_data(priv->i3cdev, xfers, ARRAY_SIZE(xfers),
+				       &ibi_payload[0], ARRAY_SIZE(ibi_payload));
 	if (ret)
 		goto out_packet;
 	ret = count;
 
-	/*
-	 * TODO: Add support for IBI generation - it should be done only if IBI
-	 * are enabled (the Active Controller may disabled them using CCC for
-	 * that). Otherwise (if IBIs are disabled), we should make sure that when
-	 * Active Controller issues GETSTATUS CCC the return value indicates
-	 * that data is ready.
-	 */
 out_packet:
 	kfree(tx_data);
 	return ret;
@@ -294,7 +344,7 @@
 {
 	struct device *parent = i3cdev_to_dev(i3cdev);
 	struct i3c_target_mctp *priv;
-	struct device *dev;
+	dev_t devt;
 	int ret;
 
 	priv = devm_kzalloc(parent, sizeof(*priv), GFP_KERNEL);
@@ -311,16 +361,17 @@
 
 	cdev_init(&priv->cdev, &i3c_target_mctp_fops);
 	priv->cdev.owner = THIS_MODULE;
-	ret = cdev_add(&priv->cdev, i3c_target_mctp_devt, 1);
+	devt = MKDEV(MAJOR(i3c_target_mctp_devt), priv->id);
+	ret = cdev_add(&priv->cdev, devt, 1);
 	if (ret) {
 		ida_free(&i3c_target_mctp_ida, priv->id);
 		return ret;
 	}
 
-	dev = device_create(i3c_target_mctp_class, parent, i3c_target_mctp_devt,
-			    NULL, "i3c-mctp-target-%d", priv->id);
-	if (IS_ERR(dev)) {
-		ret = PTR_ERR(dev);
+	priv->dev = device_create(i3c_target_mctp_class, parent, devt, NULL,
+				  "i3c-mctp-target-%d", priv->id);
+	if (IS_ERR(priv->dev)) {
+		ret = PTR_ERR(priv->dev);
 		goto err;
 	}
 
@@ -338,9 +389,15 @@
 
 static void i3c_target_mctp_remove(struct i3c_device *i3cdev)
 {
-	struct i3c_target_mctp *priv = dev_get_drvdata(i3cdev_to_dev(i3cdev));
+	struct i3c_target_mctp *priv = i3cdev_get_drvdata(i3cdev);
+
+	if (priv->client) {
+		priv->client->priv = NULL;
+		kobject_put(&priv->cdev.kobj);
+		module_put(priv->cdev.owner);
+	}
 
-	device_destroy(i3c_target_mctp_class, i3c_target_mctp_devt);
+	device_destroy(i3c_target_mctp_class, priv->dev->devt);
 	cdev_del(&priv->cdev);
 	ida_free(&i3c_target_mctp_ida, priv->id);
 }
diff -Naur linux_org/drivers/i3c/mctp/Kconfig linux/drivers/i3c/mctp/Kconfig
--- linux_org/drivers/i3c/mctp/Kconfig	2024-02-06 01:18:16.247869524 +0800
+++ linux/drivers/i3c/mctp/Kconfig	2024-02-15 00:00:02.546932826 +0800
@@ -9,6 +9,7 @@
 config I3C_TARGET_MCTP
     tristate "I3C Target MCTP driver"
     depends on I3C
+    depends on I2C
 help
     Say yes here to enable the I3C MCTP driver for I3C HW that is
     configured as an I3C Target Device on the I3C Bus.
diff -Naur linux_org/include/linux/i3c/ccc.h linux/include/linux/i3c/ccc.h
--- linux_org/include/linux/i3c/ccc.h	2024-02-06 01:18:16.459866416 +0800
+++ linux/include/linux/i3c/ccc.h	2024-02-15 00:54:34.000000000 +0800
@@ -135,7 +135,7 @@
 struct i3c_ccc_defslvs {
 	u8 count;
 	struct i3c_ccc_dev_desc master;
-	struct i3c_ccc_dev_desc slaves[0];
+	struct i3c_ccc_dev_desc slaves[];
 } __packed;
 
 /**
@@ -243,7 +243,7 @@
  */
 struct i3c_ccc_setbrgtgt {
 	u8 count;
-	struct i3c_ccc_bridged_slave_desc bslaves[0];
+	struct i3c_ccc_bridged_slave_desc bslaves[];
 } __packed;
 
 
@@ -357,7 +357,7 @@
  */
 struct i3c_ccc_setxtime {
 	u8 subcmd;
-	u8 data[0];
+	u8 data[];
 } __packed;
 
 #define I3C_CCC_GETXTIME_SYNC_MODE	BIT(0)
diff -Naur linux_org/include/linux/i3c/device.h linux/include/linux/i3c/device.h
--- linux_org/include/linux/i3c/device.h	2024-02-06 01:18:16.247869524 +0800
+++ linux/include/linux/i3c/device.h	2024-02-15 00:54:08.000000000 +0800
@@ -355,6 +355,8 @@
 			     int ncmds);
 
 int i3c_device_generate_ibi(struct i3c_device *dev, const u8 *data, int len);
+int i3c_device_put_read_data(struct i3c_device *dev, struct i3c_priv_xfer *xfers, int nxfers,
+			     const u8 *ibi_data, int ibi_len);
 
 void i3c_device_get_info(struct i3c_device *dev, struct i3c_device_info *info);
 
@@ -411,4 +413,25 @@
 
 int i3c_device_control_pec(struct i3c_device *dev, bool pec);
 
+/**
+ * enum i3c_event - List of possible events could be send/published to
+ *		    registered devices.
+ * @i3c_event_prepare_for_rescan: Event send when controller driver is going to
+ *				  run bus discovery again.
+ * @i3c_event_rescan_done: Event send when controller driver run bus discovery
+ *			   again.
+ */
+enum i3c_event {
+	i3c_event_prepare_for_rescan = 0,
+	i3c_event_rescan_done,
+};
+
+/**
+ * i3c_event_cb - callback registered by device driver and used by controller
+ *		  driver to publish event.
+ */
+typedef void (*i3c_event_cb)(struct i3c_device *dev, enum i3c_event event);
+
+void i3c_device_register_event_cb(struct i3c_device *dev, i3c_event_cb cb);
+
 #endif /* I3C_DEV_H */
diff -Naur linux_org/include/linux/i3c/master.h linux/include/linux/i3c/master.h
--- linux_org/include/linux/i3c/master.h	2024-02-06 01:18:16.247869524 +0800
+++ linux/include/linux/i3c/master.h	2024-02-15 00:53:03.000000000 +0800
@@ -171,6 +171,10 @@
  * @pid: I3C Provisional ID exposed by the device. This is a unique identifier
  *	 that may be used to attach boardinfo to i3c_dev_desc when the device
  *	 does not have a static address
+ * @dcr: I3C Device Characteristic Register value. This value is used to
+ *	 identify type of I3C device. It is read during ENTDAA procedure but in
+ *	 case static configuration it could be also provided in DTS as a
+ *	 boardinfo
  * @of_node: optional DT node in case the device has been described in the DT
  *
  * This structure is used to attach board-level information to an I3C device.
@@ -211,6 +215,8 @@
  *	 code should manipulate it in when updating the dev <-> desc link or
  *	 when propagating IBI events to the driver
  * @boardinfo: pointer to the boardinfo attached to this I3C device
+ * @event_cb: I3C framework event callback used to publish events to registered
+ *	      devices' drivers
  *
  * Internal representation of an I3C device. This object is only used by the
  * core and passed to I3C master controller drivers when they're requested to
@@ -226,6 +232,7 @@
 	struct i3c_device_ibi_info *ibi;
 	struct i3c_device *dev;
 	const struct i3c_dev_boardinfo *boardinfo;
+	i3c_event_cb event_cb;
 };
 
 /**
@@ -312,7 +319,6 @@
  *		this can change over the time. Will be used to let a master
  *		know whether it needs to request bus ownership before sending
  *		a frame or not
- * @id: bus ID. Assigned by the framework when register the bus
  * @addrslots: a bitmap with 2-bits per-slot to encode the address status and
  *	       ease the DAA (Dynamic Address Assignment) procedure (see
  *	       &enum i3c_addr_slot_status)
@@ -399,9 +405,6 @@
  *		      all CCC commands are supported.
  * @send_ccc_cmd: send a CCC command
  *		  This method is mandatory.
- * @send_hdr_cmds: send one or several HDR commands. If there is more than one
- *		   command, they should ideally be sent in the same HDR
- *		   transaction
  * @priv_xfers: do one or several private I3C SDR transfers
  *		This method is mandatory.
  * @attach_i2c_dev: called every time an I2C device is attached to the bus.
@@ -487,6 +490,7 @@
 /**
  * struct i3c_master_controller - I3C master controller object
  * @dev: device to be registered to the device-model
+ * @bus_id: bus ID. Assigned by the framework when register the bus
  * @this: an I3C device object representing this master. This device will be
  *	  added to the list of I3C devs available on the bus
  * @i2c: I2C adapter used for backward compatibility. This adapter is
@@ -506,6 +510,9 @@
  *	in a thread context. Typical examples are Hot Join processing which
  *	requires taking the bus lock in maintenance, which in turn, can only
  *	be done from a sleep-able context
+ * @daa_lock: protect DAA calls to single DAA at a time.
+ * @bus_driver_context: context of the hardware/controller driver, it could be
+ *			shared among multiple @i3c_master_controller
  *
  * A &struct i3c_master_controller has to be registered to the I3C subsystem
  * through i3c_master_register(). None of &struct i3c_master_controller fields
@@ -514,6 +521,7 @@
  */
 struct i3c_master_controller {
 	struct device dev;
+	int bus_id;
 	struct i3c_dev_desc *this;
 	struct i2c_adapter i2c;
 	const struct i3c_master_controller_ops *ops;
@@ -529,6 +537,8 @@
 	} boardinfo;
 	struct i3c_bus bus;
 	struct workqueue_struct *wq;
+	void *bus_driver_context;
+	struct mutex daa_lock;
 };
 
 /**
@@ -568,6 +578,10 @@
 int i3c_master_defslvs_locked(struct i3c_master_controller *master);
 int i3c_master_rstdaa_locked(struct i3c_master_controller *master,
 				    u8 addr);
+
+struct i3c_dev_desc *i3c_master_find_i3c_dev_by_addr(const struct i3c_master_controller *master,
+						     u16 addr);
+
 int i3c_master_get_free_addr(struct i3c_master_controller *master,
 			     u8 start_addr);
 
diff -Naur linux_org/include/linux/i3c/mctp/i3c-mctp.h linux/include/linux/i3c/mctp/i3c-mctp.h
--- linux_org/include/linux/i3c/mctp/i3c-mctp.h	2024-02-06 01:18:16.247869524 +0800
+++ linux/include/linux/i3c/mctp/i3c-mctp.h	2024-02-15 00:00:02.546932826 +0800
@@ -18,6 +18,8 @@
 #define MCTP_MSG_HDR_VENDOR_OFFSET	1
 #define MCTP_MSG_HDR_OPCODE_OFFSET	4
 
+#define I3C_MCTP_MIN_PACKET_SIZE	5
+
 struct i3c_mctp_client;
 
 struct mctp_protocol_hdr {
@@ -39,6 +41,7 @@
 
 void *i3c_mctp_packet_alloc(gfp_t flags);
 void i3c_mctp_packet_free(void *packet);
+void i3c_mctp_flush_rx_queue(struct i3c_mctp_client *client);
 
 int i3c_mctp_get_eid(struct i3c_mctp_client *client, u8 domain_id, u8 *eid);
 int i3c_mctp_send_packet(struct i3c_device *i3c, struct i3c_mctp_packet *tx_packet);
diff -Naur linux_org/include/linux/i3c/target.h linux/include/linux/i3c/target.h
--- linux_org/include/linux/i3c/target.h	2024-02-06 01:18:16.247869524 +0800
+++ linux/include/linux/i3c/target.h	2024-02-15 00:00:02.546932826 +0800
@@ -14,6 +14,9 @@
 	void (*bus_cleanup)(struct i3c_master_controller *master);
 	int (*priv_xfers)(struct i3c_dev_desc *dev, struct i3c_priv_xfer *xfers, int nxfers);
 	int (*generate_ibi)(struct i3c_dev_desc *dev, const u8 *data, int len);
+	int (*put_read_data)(struct i3c_dev_desc *dev, struct i3c_priv_xfer *xfers, int nxfers,
+			     const u8 *data, int len);
+	u8 (*get_dyn_addr)(struct i3c_master_controller *master);
 };
 
 int i3c_target_register(struct i3c_master_controller *master, struct device *parent,
diff -Naur linux_org/include/linux/ptr_ring.h linux/include/linux/ptr_ring.h
--- linux_org/include/linux/ptr_ring.h	2023-07-27 14:37:45.000000000 +0800
+++ linux/include/linux/ptr_ring.h	2024-02-06 01:58:18.248652827 +0800
@@ -467,7 +467,7 @@
 {
 	if (size > KMALLOC_MAX_SIZE / sizeof(void *))
 		return NULL;
-	return kvmalloc_array(size, sizeof(void *), gfp | __GFP_ZERO);
+	return kmalloc_array(size, sizeof(void *), gfp | __GFP_ZERO);
 }
 
 static inline void __ptr_ring_set_size(struct ptr_ring *r, int size)
@@ -604,7 +604,7 @@
 	spin_unlock(&(r)->producer_lock);
 	spin_unlock_irqrestore(&(r)->consumer_lock, flags);
 
-	kvfree(old);
+	kfree(old);
 
 	return 0;
 }
@@ -644,7 +644,7 @@
 	}
 
 	for (i = 0; i < nrings; ++i)
-		kvfree(queues[i]);
+		kfree(queues[i]);
 
 	kfree(queues);
 
@@ -652,7 +652,7 @@
 
 nomem:
 	while (--i >= 0)
-		kvfree(queues[i]);
+		kfree(queues[i]);
 
 	kfree(queues);
 
@@ -667,7 +667,7 @@
 	if (destroy)
 		while ((ptr = ptr_ring_consume(r)))
 			destroy(ptr);
-	kvfree(r->queue);
+	kfree(r->queue);
 }
 
 #endif /* _LINUX_PTR_RING_H  */
--- linux_org/include/uapi/linux/i3c/i3c-mctp.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/uapi/linux/i3c/i3c-mctp.h	2024-02-15 02:49:05.000000000 +0800
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/* Copyright (c) 2022 Intel Corporation */
+
+#ifndef _UAPI_LINUX_I3C_MCTP_H
+#define _UAPI_LINUX_I3C_MCTP_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/*
+ * maximum possible number of struct eid_info elements stored in list
+ */
+#define I3C_MCTP_EID_INFO_MAX 256
+
+/*
+ * MCTP operations
+ * @I3C_MCTP_SET_EID_INFO: write or overwrite already existing list of
+ * CPU EID and Domain ID mappings
+ * @I3C_MCTP_SET_OWN_EID: write/overwrite own EID information
+ * @I3C_MCTP_IOCTL_REGISTER_DEFAULT_CLIENT: register the client to
+ * process MCTP packets over I3C
+ */
+
+struct i3c_mctp_eid_info {
+	__u8 eid;
+	__u8 dyn_addr;
+	__u8 domain_id;
+};
+
+struct i3c_mctp_set_eid_info {
+	__u64 ptr;
+	__u16 count;
+};
+
+struct i3c_mctp_set_own_eid {
+	__u8 eid;
+};
+
+#define I3C_MCTP_IOCTL_BASE    0x69
+
+#define I3C_MCTP_IOCTL_SET_EID_INFO \
+	_IOW(I3C_MCTP_IOCTL_BASE, 0x41, struct i3c_mctp_set_eid_info)
+#define I3C_MCTP_IOCTL_SET_OWN_EID \
+	_IOW(I3C_MCTP_IOCTL_BASE, 0x42, struct i3c_mctp_set_own_eid)
+#define I3C_MCTP_IOCTL_REGISTER_DEFAULT_CLIENT \
+	_IO(I3C_MCTP_IOCTL_BASE, 0x43)
+
+#endif /* _UAPI_LINUX_I3C_MCTP_H */
